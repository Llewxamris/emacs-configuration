#+TITLE: Maxwell Haley's Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:emacs-lisp :tangle yes
#  LocalWords:  Leuven Flycheck modeline keybinds Cliplink ido minibuffer GC ui
#  LocalWords:  iBuffer Dired Magit ELPA MELPA Keybinds Keybind SPC SCP UTF CLI
#  LocalWords:  emacs modeline paren pinky dired magit Magit's LaTeX Flyspell
#  LocalWords:  flyspell lang lsp flycheck imenu ibuffer Avy linter Yasnippet
#  LocalWords:  backend Writegood actioned actioning init Linum GUIs Git's
#  LocalWords:  shatteringly

* Forward
My living monolith of a Emacs configuration file. Bred through trial, error, and
peeking at the configurations of people far more wise than I. Here's a list of
some of those configurations I've lifted. Can't let me get away red handed.

- [[https://github.com/angrybacon/dotemacs][angrybacon/dotemacs]]
- [[https://github.com/valignatev/dotfiles][valignatev/dotfiles]]
- [[https://github.com/sachac/.emacs.d][sachac/.emacs.d]]
- [[https://github.com/wasamasa/dotemacs][wasamasa/dotemacs]]

The entire configuration file is written out in Emacs Org Mode. The goal is to
describe and justify my decisions in a way that both:

1. Anyone interested in building their own configuration can browse through my
own and make informed decisions on what they want to co-opt
2. I can figure out /"What the f--- was I thinking."/ in the next few months

I also tried to use some humour to make reading through this YAML file on
steroids enjoyable. I apologize in advance.

* Early init
Emacs supports loading a file with the name ~early-init.el~ early in the startup
process. Specifically, before initialising the package manager & before creating
any GUI elements.

** Package manager
The package manager (in Emacs 27+) is automatically initialised /before/
evaluating ~init.el~. To avoid having to re-initialising the package manager, I
need to set any custom properties within the early init file.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  ;; -*- lexical-binding: t; -*-
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.milkbox.net/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("gnu" . "https://elpa.gnu.org/packages/")))

  (unless (bound-and-true-p package--initialized)
    (setq package-enable-at-startup nil)
     (package-initialize))

  (eval-and-compile
    (setq use-package-verbose
          (not (bound-and-true-p byte-compile-current-file))))

  (eval-and-compile
    (let ((package-dir
           (expand-file-name "packages" user-emacs-directory)))
      (add-to-list 'load-path package-dir)))
#+END_SRC

** User interface elements
Emacs renders all of the user interface elements before evaluating the init
file. This means wasting cycles on elements that I will be changing/removing.
Luckily for me, anything in the early init file evaluates /before/ UI rendering
begins. This means Emacs is not rendering disabled elements, and it is setting
some elements correctly on the first draw.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  ;; Three bars in one night? Good.
  ;; Three bars of gold? Great.
  ;; Three bars in a slot machine? Amazing!
  ;; Three bars in Emacs?: Bad.
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  ;; Inhibit the resizing of fonts which causes slowdowns on any font resizing.
  (setq frame-inhibit-implied-resize t)

  ;; Explicitly set the font backend to Cairo with HarfBuzz as the shaping engine.
  ;; This opens up the door to better ligature support in the future.
  (add-to-list 'default-frame-alist '(font-backend . "ftcrhb"))

  ;; Ignore the X resources file. I don't use X resources for anything, so there's
  ;; no reason to even look at it.
  (advice-add #'x-apply-session-resources :override #'ignore)
#+END_SRC

* Preparation & Package Management
** Use Package
/Ensure/ ~use-package~ is always installed alongside this configuration. I
/ensure/ to always /ensure/ my packages are available, and then /ensure/ I have
the newest packages available.

Any built-in Emacs packages, or packages that are actually apart of a separate
package, are not ensured by adding ~:ensure nil~ to their declaration.

Also included is ~auto-package-update~. It automatically updates packages three
days after the previous upgrade was ran.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-and-compile
    (setq use-package-always-ensure t))

  (eval-when-compile
    (require 'use-package))

  (put 'use-package 'lisp-indent-function 1)

  (use-package auto-package-update
    :custom
    (auto-package-update-interval 3)
    (auto-package-update-delete-old-versions t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe))
#+END_SRC

** Custom
Hide away the ~custom~ configurations by dumping it into the void. I try to
avoid using ~custom~ in general. I find figuring out how to do it manually much
more +infuriating+ entertaining.

#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :ensure nil
    :custom
    (custom-file null-device))
#+END_SRC

** Automatically Byte Compile Emacs Lisp Libraries
Byte compiling Emacs Lisp files allows them to load and execute faster. I've
never tested the speed difference of compiled vs. not-compiled, but I assume the
time spent setting up my Emacs configuration negates the performance increase.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config
      ;; Auto-compile on both loading and saving.
      (auto-compile-on-load-mode)
      (auto-compile-on-save-mode))
#+END_SRC

* Personal package
I am trying out keeping my custom variables/constants/macros/functions in their
own /"external"/ package. They are all defined within this Org document, but I
have set them to tangle to a different directory under the name ~max.el~. My
thought was that keeping everything that is custom tooled together will make it
easier to hunt them done. I guess I will see.

#+BEGIN_SRC emacs-lisp :tangle lib/max.el :mkdirp yes
  (require 'company)

  (defgroup max nil
    "Personal configuration options."
    :group 'environment)

  (defcustom max-display-font-name "Iosevka"
    "Defines the name of the display font."
    :type 'string
    :group 'max)

  (defconst max-on-personal (eq system-type 'gnu/linux)
    "If non-nil, Emacs is running on my personal laptop.")

  (defconst max-on-work (eq system-type 'windows-nt)
    "If non-nil, Emacs is running on my work laptop.")

  (defconst max-font-sizes-alist '((small . 9) (large . 10.5))
    "An alist containing predefined \"small\" and \"large\" font sizes.")

  (defmacro when-personal (&rest body)
    "Executes BODY if `max-on-personal' is non-nil."
    `(when ,max-on-personal
      ,(cons 'progn body)))

  (defmacro when-work (&rest body)
    "Executes BODY if `max-on-work' is non-nil."
    `(when ,max-on-work
       ,(cons 'progn body)))

  (defun max-set-company-backends (backends)
    "Creates a local copy of var `company-backends' and sets it to BACKENDS.
  BACKENDS is a list following the structure of `company-backends'. This allows me
  to customize the list of back ends per major-mode."
    (make-local-variable 'company-backends)
    (set 'company-backends ())
    (add-to-list 'company-backends backends))

  (defun max-set-font-based-on-monitors ()
    "Set the font and font size based on the available displays."
    (interactive)
    (let* ((display-size (if (= (length (display-monitor-attributes-list))
                                1)
                             'small
                           'large))
           (font-size (alist-get display-size max-font-sizes-alist)))
      (set-face-attribute 'default nil
                          :font max-display-font-name
                          :height (truncate (* 10 font-size)))
      (set-face-attribute 'fixed-pitch nil
                          :font max-display-font-name
                          :height (truncate (* 10 font-size)))))

  (defun max-set-prettify-symbols (&rest symbols)
    "Creates a local copy of `prettify-symbols-alist', and adds to it SYMBOLS.
  The intention is for mode-specific hooks to call this function with the set of
  SYMBOLS specific to that mode. Declare common prettify symbols in the
  `prettify-symbols-mode' declaration.

  This function does not enable `prettify-symbols-mode' in the modes that call it."
    (make-local-variable 'prettify-symbols-alist)
    (when symbols
      (seq-do
       (lambda (symbol)
         (push symbol prettify-symbols-alist))
       symbols)))

  (provide 'max)
#+END_SRC

I load the previous package using ~use-package~'s ~load-path~ mechanism.

#+BEGIN_SRC emacs-lisp
  (use-package max
    :load-path "~/.config/Emacs/lib/"
    :functions max-set-font-based-on-monitors
    :config
    (max-set-font-based-on-monitors))
#+END_SRC

* Emacs General
** Essentials
Emacs comes with a large set of defaults designed to make adoption simple for
new users. Once you get a hang of Emacs, some of these defaults can feel like
they get in the way or are unnecessary. There are also some settings that are
not set by default to avoid confusing new users. And like the set defaults, some
of them may be useful once you are more familiar with Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :ensure nil
    :bind (([f5] . max/reload-emacs-configuration)
           ([f6] . max/open-emacs-configuration))
    :init
    ;; Set email based on current operating system.
    (if (eq system-type 'windows-nt)
        (setq user-mail-address "maxwell.haley@hrsdc-rhdcc.gc.ca")
      (setq user-mail-address "maxwell.r.haley@gmail.com"))

    :config
    (defun max/reload-emacs-configuration ()
      (interactive)
      (load-file (concat user-emacs-directory "init.el")))

    (defun max/open-emacs-configuration ()
      "Open ~config.org~, my literate Emacs configuration file.
  If the file is already open in another buffer, switch to that buffer."
      (interactive)
      (find-file (concat user-emacs-directory "config.org")))

    ;; Force syntax highlighting for all supported major modes.
    (global-font-lock-mode t)

    ;; Disable tooltip popups.
    (tooltip-mode -1)

    ;; Change the "Yes or No" prompt to just be "y or n".
    (defalias 'yes-or-no-p 'y-or-n-p)

    ;; Disable font compacting on GC when on Windows. Trades off removing
    ;; some lag for increased memory usage.
    (when (eq system-type 'windows-nt)
      (setq inhibit-compacting-font-caches t))

    :custom
    (use-full-name "Maxwell R. Haley")
    ;; Disable the startup screen & message.
    (inhibit-startup-screen t)

    ;; Disable the bell that makes me feel shame every time it lets me
    ;; know I fumbled a keystroke. Worse, its almost like hearing the
    ;; bell guarantees the next few strokes will also be fumbled
    ;; resulting in more bells. Disable this existential horror please.
    (ring-bell-function 'ignore)          ;*ding-ding* SHAME. *ding-ding* SHAME.

    ;;	Show keystrokes after 0.1 seconds. Any longer and the panic sets in.
    (echo-keystrokes 0.01)

    ;; Do not show a dialog box when mouse commands result in a question
    ;; being asked. I actively avoid using the mouse, and accidently
    ;; triggering a popup is very frustrating.
    (use-dialog-box t)

    ;; Use spaces instead of tabs. And when tabs are seen, limit them to two
    ;; characters.
    (indent-tabs-mode nil)
    (tab-width 2)

    ;; Use UTF-8 encoding, because this is ${CURRENT_YEAR}.
    (locale-coding-system 'utf-8)

    ;; Always load the newest version of a file.
    (load-prefer-newer t)

    (x-underline-at-descent-line t "
  Underline a word at the decent point (the lowest point of a character like 'g'
  or 'y')."))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package simple
    :ensure nil
    :config
    ;; Show column numbers on the modeline.
    (column-number-mode)

    ;; Show the size of the current buffer in the modeline.
    (size-indication-mode)

    ;; Visually wrap lines when the characters are too close to the fringe.
    (global-visual-line-mode 1)
    :custom
    ;; If the cursor is on the end of a line, stay on the end of the line when
    ;; moving to the next or previous line.
    (track-eol t)

    ;; Always show the current line number and column number
    ;; in the buffer. When both enabled, they appear like this:
    ;; ~~~
    ;; (line, col)
    ;; ~~~
    (line-number-mode t)
    (column-number-mode t)

    ;; Adds some curly arrows to help show which lines are being effected by
    ;; visual line wrapping.
    (visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow)))
#+END_SRC

Which-key is a fantastic package for folks new to Emacs, experienced with Emacs,
and in-between. After entering a partial key sequence, it displays all
additional keys that one can press and what function/prefix it will invoke.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :hook (after-init . which-key-mode)
    :config
    ;; Prefixes bound by `use-package' do not generate nice prefix names, so I
    ;; need to declare them manually.
    (which-key-add-key-based-replacements
      "<leader> c" '("flyspell prefix" . "Flyspell keys")
      "<leader> w" '("evil-window prefix" . "Evil window keys"))
    :custom
    (which-key-idle-delay 0.5 "
  Only wait half a second before displaying the popup.")
    (which-key-enable-extended-define-key t "
  Extend the define-key symbol to support which-key."))
#+END_SRC

Automatically decompress archives when reading, and then compress again when
writing.

#+BEGIN_SRC emacs-lisp
  (use-package jka-cmpr-hook
    :ensure nil
    :config
    (auto-compression-mode t))
#+END_SRC

Enable the Garbage Collector Magic Hack. This will kick in the built in GC
whenever the system is idle,

#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :ensure t
    :init
    (gcmh-mode 1))
#+END_SRC

** Files
Of course, the core purpose of a file editor is to edit files. And whenever I
edit a file, the next logical step is to save that file. Emacs has plenty of
built in saving functionality, as well as the ability to make plenty of backups
in case you forgot to save.

#+BEGIN_SRC emacs-lisp
  (use-package files
    :ensure nil
    :hook
    ;; Always delete trailing whitespace when saving a file.
    (before-save . delete-trailing-whitespace)

    ;; Automatically save buffers when losing focus, or when a frame is deleted.
    (focus-out-hook . save-some-buffers)
    (delete-frame-functions . save-some-buffers)

    :custom
    ;; Emacs auto-backups files, which is great. But, it dumps them in the current
    ;; directory, which is terrible. Instead, dump them into ~.emacs.d/~.
    (backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory))))

    ;; I don't want to have my hard drive littered with backups, so I set Emacs to
    ;; only keep up to three backup versions. I also don't want to have a nag every
    ;; time it wants to delete a backup. I also include version controlled files,
    ;; just in case.
    (version-control t)
    (kept-old-versions 2)
    (delete-old-versions t)
    (vc-make-backup-files t)

    ;; Always include a trailing newline at the end of a file.
    (require-final-newline t)
    (delete-trailing-lines nil))
#+END_SRC

It is also useful to automatically refresh buffers. That is: If the content of a
buffer changes (such as a file changing on disk), then redraw the buffer. I also
set it to refresh non-file buffers (such as Dired buffers), and to suppress the
nag.

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :ensure nil
    :config
    (global-auto-revert-mode t)
    :custom
    (global-auto-revert-non-file-buffers t)
    (auto-revert-verbose nil))
#+END_SRC

I also want to backup all of the commands I've used, so I can re-invoke them in
later sessions. Command history is essential for any command based environment.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :ensure nil
    :config
    (savehist-mode)
    :custom
    ;; Save all minibuffer histories
    (savehist-save-minibuffer-history t)
    ;; Set the file location for storing minibuffer history
    (savehist-file (expand-file-name "savehist" user-emacs-directory))
    ;; Include the kill-ring, search-ring, and regexp-search-ring to the
    ;; history file.
    (savehist-additional-variables '(kill-ring
                                     search-ring
                                     regexp-search-ring)))
#+END_SRC

Tramp let's me use Emacs to edit remote files. For example, changing a Docker
compose file from the comfort of my local machine. I default to editing over SSH
instead of using SCP. [[https://www.emacswiki.org/emacs/TrampMode#toc12][I also need to override the shell prompt pattern to
prevent Tramp from hanging.]]

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :ensure nil
    :custom
    (tramp-default-method "ssh" "SSH is faster than SCP.")
    (tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*"
                                "Not having this pattern set causes Tramp to hang on connection."))
#+END_SRC

** Graphical User Interface
Undo/Redo window layouts using ~C-c <left>~ and ~C-c <right>~. Lets me fix
accidental destruction the layout of windows and buffers.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure nil
    :config
    (winner-mode 1))
#+END_SRC

** Editor
*** Character Encoding & General Formatting
Use UTF-8 encoding everywhere. I rarely run Emacs in a terminal, and even then
my terminal of choice also supports UTF-8. No reason to not enable.

#+BEGIN_SRC emacs-lisp
  (use-package mule
    :ensure nil
    :config
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)

    :custom
    (sentence-end-double-space nil))
#+END_SRC

*** Colour Theme
I have been obsessing with the [[https://gitlab.com/dj_goku/modus-themes][Modus Operandi]] theme. I love the focus on
accessibility. It also is not overly busy as far as colours go, but it is also
not visually boring.

#+BEGIN_SRC emacs-lisp
  (use-package modus-operandi-theme
    :config
    ;; Load the theme unless running without an interactive terminal.
    (unless noninteractive
      (load-theme 'modus-operandi t))
    :custom
    (modus-operandi-theme-org-blocks 'greyscale)
    (modus-operandi-theme-section-headings t)
    (modus-operandi-theme-scale-headings t)
    (modus-operandi-theme-visible-fringe t)
    (modus-operandi-theme-slanted-constructs t)
    (modus-operandi-theme-bold-constructs t))
#+END_SRC

*** Highlighting & Pair Matching
Highlight the row the cursor is currently on.

#+BEGIN_SRC emacs-lisp
  (use-package hl-line
    :config
    (global-hl-line-mode))
#+END_SRC

When the cursor is over a parenthesis, highlight all of the content between that
parenthesis and it's matching opening/closing parenthesis. This is useful when
working with Lisp, but I have found it helpful in other situations as well. So I
set it globally.

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :config
    (show-paren-mode)

    (defun max/toggle-show-paren-style ()
      "Toggle between the \"expression\" and \"parenthesis\" `show-paren-mode' style."
      (interactive)
      (cond ((eq show-paren-style 'expression)
             (setq show-paren-style 'parenthesis))
            ((eq show-paren-style 'parenthesis)
             (setq show-paren-style 'expression))))
    :custom
    ;; By default, highlight the entire expression between the two parens.
    (show-paren-style 'expression)
    ;; No delay between putting the cursor on a paren, and highlighting.
    (show-paren-delay 0))
#+END_SRC

Automatically insert a closing symbol after entering an opening symbol (paren.,
bracket, brace, etc.). The closing symbol is after the point of the cursor, so I
can keep typing without having to adjust to the newly entered text.

#+BEGIN_SRC emacs-lisp
  (use-package elec-pair
    :config
    (electric-pair-mode))
#+END_SRC

*** Doom Modeline
A """minimalist""" modeline. It's minimalist, so that justifies satisfying my
need for fancy colours and icons everywhere I look so I can keep my ADD rattled
brain distracted while the rest of me tries to do real work.

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :custom
    ;; Forcefully enable icons in the modeline. This is necessary when running
    ;; Emacs as a daemon.
    (doom-modeline-icon t))

  (use-package all-the-icons)
#+END_SRC

*** Relative Line Numbering
Vim's /relative line numbers/ was an invaluable feature that made using Vim's
input style simple. It makes taking advantage of multi-line motions or edits
simple for someone like me who is terrible at on the fly mental math.

I previously used the [[https://github.com/coldnew/linum-relative][linum-relative]] package for relative line numbering. Now, I
use the ~display-line-numbers~ package that comes with Emacs 26+. Linum had
major performance problems when working on large files, including this one. I
actually disabled ~linum-mode~ in all Org files because it became such a
problem. These performance issues went away after switching to
~display-line-numbers~.

#+BEGIN_SRC emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :config
    (global-display-line-numbers-mode)
    :custom
    (display-line-numbers-type 'relative) ; Display numbers relatively
    (display-line-numbers-grow-only t) ; Only increase the width, never shrink
    (display-line-numbers-width-start t) ; Start as wide as the largest number
    (display-line-numbers-widen t)) ; Display the true number when narrowing
#+END_SRC

*** Fill column indicator
The /fill column indicator/ draws a character down a particular column to
visually indicate where a certain column begins. This is useful if you are
following the 80 column rule, or following a style guide that requires keeping
to a specific number of characters per line.

#+BEGIN_SRC emacs-lisp
  (use-package display-fill-column-indicator
    :ensure nil
    :config
    (global-display-fill-column-indicator-mode)
    :custom
    (fill-column 80)
    (display-fill-column-indicator t)
    (display-fill-column-indicator-column t) ; use ~fill-column~ variable
    )
#+END_SRC

*** Smooth Scrolling
Leaves just a bit of room at the bottom and top of the window when scrolling.
Something about it just feels so right. Uses the [[https://github.com/aspiers/smooth-scrolling][smooth-scrolling package]].

#+BEGIN_SRC emacs-lisp
  (use-package smooth-scrolling
    :config
    (smooth-scrolling-mode 1))
#+END_SRC

*** Expand Region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind ("<leader> =" . #'er/expand-region))
#+END_SRC

*** Edit Indirect
[[https://github.com/Fanael/edit-indirect][Edit Indirect]] allows the user to open any region in a separate buffer, edit it,
then commit those changes back to the original buffer. It is similar to Org
Mode's ability to open source or quote blocks in their own buffer.

This is super useful when I am editing a single function, or writing a single
paragraph. I can make changes in a buffer independent of what surrounds it. I
can also make destructive changes without worrying about accidental changing
something outside of my scope.

#+BEGIN_SRC emacs-lisp
  (use-package edit-indirect
    :bind (("<leader> \"" . #'edit-indirect-region)
           :map edit-indirect-mode-map
           ("<localleader> s" . #'edit-indirect-save)
           ("<localleader> '" . #'edit-indirect-commit)
           ("<localleader> c" . #'edit-indirect-commit)
           ("<localleader> k" . #'edit-indirect-abort)))
#+END_SRC

* Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :bind (("s-u" . universal-argument)
           ("<leader> b" . ido-switch-buffer)
           ("<leader> e" . eval-last-sexp)
           ("<leader> f" . find-file)
           ("<leader> s" . save-buffer)
           ("<leader> h" . help-command))
    :bind-keymap ("<leader> w" . evil-window-map)
    :commands (evil-mode evil-set-leader)
    :defines org-src-mode-map
    :hook (after-init . evil-mode)
    :config
    (evil-set-leader 'motion (kbd "SPC") nil)
    (evil-set-leader 'motion (kbd ",") t)
    :custom
    (evil-want-C-u-scroll t "Treat C-u the same as Vim.")

    (evil-want-keybinding nil "
  Do not load evil-keybindings. This is handled by evil-collection."))
#+END_SRC

~evil-collection~ attempts to fill the space between "just installed evil-mode"
and "rebound every single key to properly fit evil-mode". it attempts to create
a consistent key bind experience across all modes, including some third-party
modes.

#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :after evil
    :init
    (evil-collection-init)
    :custom
    (evil-collection-company-use-tng nil))
#+END_SRC

* Ace
#+BEGIN_SRC emacs-lisp
  (use-package ace-link
    :config
    (ace-link-setup-default (kbd "<localleader> o")))
#+END_SRC

* Completion
** Company
[[http://company-mode.github.io/][Company]] is a framework for text insertion completion. For example, automatically
completing function invocations while typing them out. Or suggesting words while
editing prose.

 #+BEGIN_SRC emacs-lisp
   (use-package company
     :demand
     :bind (:map company-active-map
                 ("C-d"       . company-show-doc-buffer)
                 ("<tab>"     . company-select-next)
                 ("<backtab>" . company-select-previous)
                 ("<ret>"     . nil)
                 ;; First stroke of C-n,p completes any missing, common characters.
                 ;; Second stroke moves up/down the list of completions.
                 ("C-n" . (lambda () (interactive)
                            (company-complete-common-or-cycle 1)))
                 ("C-p" . (lambda () (interactive)
                            (company-complete-common-or-cycle -1))))
     :config
     (global-company-mode)
     :custom
     (company-minimum-prefix-length 2 "
   Require two characters before starting completion.")

     (company-idle-delay 0.25 "
   Begin showing completions after a 0.25 second delay.")

     (company-backends '((company-files
                          company-keywords
                          company-capf
                          company-yasnippet)
                         '(company-abbrev company-dabbrev))
                       "
   Define the default completion engines.")

     (company-transformers '(company-sort-by-backend-importance
                             company-sort-prefer-same-case-prefix
                             company-sort-by-occurrence) "
   Define transformers that alter the order of completion candidates.")

     (company-selection-wrap-around t "
   Jump to the beginning/end of the list after reaching to beginning/end of the list.")

     (company-auto-complete-chars nil "
   Not interested in triggering auto-completion at any point.")

     (company-tooltip-align-annotations t "Right align annotations.")

     (company-dabbrev-other-buffers nil "
   Do not scan other buffers for suggestions. When a lot of buffers are open, this
   can cause noticeable slowdowns.")

     (company-dabbrev-downcase nil "
   Do not downcase any completion candidates.")

     (company-dabbrev-ignore-case nil"
   Ensure the prefix is case-sensitive."))

   (use-package company-posframe
     :after company
     :config
     (company-posframe-mode))
#+END_SRC

** Yasnippet
[[http://joaotavora.github.io/yasnippet/][Yasnippet]] is a template system that enables expanding keywords into text or code
snippets. For example, entering ~emacs-lisp_~ and hitting ~<tab>~ expands into a
full ~BLOCK_SRC~ element with the language set to ~emacs-lisp~.

 #+BEGIN_SRC emacs-lisp
   (use-package yasnippet
     :config
     (yas-global-mode))

   (use-package yasnippet-snippets
     :after yasnippet)
#+END_SRC

* ido
[[https://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] (Interactively Do Things) is a built-in minor mode that provides
"interactive" text entry. This mostly means the minibuffer will filter away all
entries that could not match your input without having to hit ~TAB~ each time.

#+BEGIN_SRC emacs-lisp
  (use-package ido
    :ensure nil
    :functions ido-everywhere
    :config
    (ido-mode)
    (ido-everywhere)

    :custom
    ;; If nothing matching, look for the sequence elsewhere in an entry.
    (ido-enable-flex-matching t ))
#+END_SRC

I do not like the default in-line display used by ido. [[https://github.com/creichert/ido-vertical-mode.el][Ido-vertical-mode]] reads
better to me, displaying all entries in a single column.

I would prefer something grid-like, such as [[https://github.com/larkery/ido-grid-mode.el][ido-grid-mode]], but I have found it
slows down Emacs too much.

#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
     :after ido
     :config
     (ido-vertical-mode)
     :custom
     (ido-vertical-define-keys 'C-n-and-C-p-only "Use C-n/C-p to move selection."))
#+END_SRC

Ido-everywhere unfortunately does not apply everywhere. To get Ido completion
nearly everywhere, I use the [[https://github.com/DarwinAwardWinner/ido-completing-read-plus][ido-completing-read+]] package. Assisting is the
[[https://github.com/DarwinAwardWinner/crm-custom][crm-custom]] package that allows Ido completion in functions that can take in
multiple inputs.

To supplement anything else that doesn't get Ido completion, I enable the
built-in ~icomplete~ mode.

#+BEGIN_SRC emacs-lisp
  (use-package ido-completing-read+
    :ensure t
    :after ido
    :config
    (ido-ubiquitous-mode))

  (use-package crm-custom
    :ensure t
    :after ido-completing-read+
    :config
    (crm-custom-mode))

  (use-package icomplete
    :after ido-completing-read+
    :config
    (icomplete-mode))
#+END_SRC

* iBuffer
Managing buffers can be a bit of a pain in Emacs. iBuffer is a great tool for
lessening that pain. It is a much better interface for buffer management that
the default ~list-buffers~ interface.

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :ensure nil
    :bind ("<leader> B b" . ibuffer))
#+END_SRC

* Dired-X
Dired-X is the extended version of the Emacs file manager Dired. I'll be honest,
I do not use Dired-X often. If I need to read a file, I'd rather use the
~fine-file~ command and navigate my file system using a path. For all file
system level operations, I would much rather switch to my shell. My Dired-X
usage is if I need to open a file and I've forgotten the name and need a list of
files/directories. And even then, it's only if I feel pressed for time, or if a
coworker is over my shoulder.

The keybinds are only for vim-like navigation. Nothing special exists outside of
those.

I customise the layout of the file system. Dired takes in standard ~ls~ flags,
which is really nice.

| Switch                    | Description                                         |
|---------------------------+-----------------------------------------------------|
| -k                        | Default to 1024-byte blocks for disk usage.         |
| -a                        | Do not ignore entries starting with ~.~.            |
| -B                        | Do not list implied entries ending with =~=.        |
| -h                        | Use human readable file sizes (1G instead of 1024). |
| -l                        | Use a long listing format.                          |
| --group-directories-first | Show directories at the top of the listing.         |

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :bind ("<leader> B d" . dired)
    :custom
    ;; ~ls~ switches passed to Dired.
    (dired-listing-switches "-kaBhl --group-directories-first")

    ;; Recursively delete and copy directories.
    (dired-recursive-deletes t)
    (dired-recursive-copies t)
    (dired-dwim-target t "
  Guess the default target directory instead of prompting."))
#+END_SRC

~diredfl~ adds additional font lock rules to Dired. Modus supports it, and I find
its choice of colours pleasing, so I enable ~diredfl~.

#+BEGIN_SRC emacs-lisp
  (use-package diredfl
    :after dired
    :config
    (diredfl-global-mode))
#+END_SRC

* Magit
Every Git-but-it-is-a-GUI application I have tried has been disappointing,
except for Magit. I think this is because other applications act as a simple
graphical wrapper around the Git. They hide away some complexities that Git has
and try to smooth down the rough edges. But the result always feels
half-complete and more like Git with training wheels. I have seen Git GUIs omit
information that I would think is crucial for end-users. Like whether or not
they are in a merge conflict state.

Magit on the other hand is not just a wrapper. It is a full fledged interface
that exposes all of Git's functionality within Emacs. It is not hiding anything,
or trying to stop you from shooting yourself in the foot. I find it as good if
not better than the Git CLI.

I do not load Magit on Windows. Git CLI on Windows is already /soul-shatteringly
slow/. Combine that with the slower speeds of Emacs on Windows and the
"/enterprise-level antivirus/" installed on my work laptop, and it becomes an
unpleasant slog to use Magit. Which is a damn shame.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("<leader> g" . magit)
    ;; Don't load Magit on my work (Windows) machine.
    :if (eq system-type 'gnu/linux)
    :custom
    (magit-completing-read-function 'magit-ido-completing-read "Use Ido completion."))

  (use-package evil-magit
    :after magit)
#+END_SRC

* Spellchecking
I use Emacs for writing documents on a regular basis. Usually this means an
~org~ or Markdown file, but this could also be LaTeX files. I also this also
could be comments within source code. Lastly, I like to draft emails within
Emacs. This means I need spellchecking on the fly within Emacs to keep my
documents professional. Flyspell is /the/ package for spell checking in Emacs. I
use ~flyspell-correct~ package to simplify correcting mistakes, and for the
~ido~ interface.

I also use ~auto-dictionary~ to automatically switch between dictionaries. I
need this occasionally to go between English and French documents.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure nil
    :hook
    ;; Auto-start flyspell within Markdown, Org-mode, TeX, and Git Commit modes.
    ;; Flyspell will scan the entire buffer to check for spelling mistakes.
    ((markdown-mode org-mode latex-mode git-commit-mode) . flyspell-mode)

    ;; Auto-start flyspell inside programming modes. In this case, Flyspell will
    ;; only scan comments and strings within the buffer to check for spelling
    ;; mistakes.
    (prog-mode . flyspell-prog-mode)
    :custom
    (flyspell-issue-welcome-flag nil "
  Do not show the welcome message when Flyspell starts.")

    (flyspell-issue-message-flag nil "
  Do not show any messages when checking words."))

  (use-package flyspell-correct
    :after flyspell
    :bind (("<leader> c c" . flyspell-correct-wrapper)
           ("<leader> c n" . flyspell-goto-next-error)))

  (use-package flyspell-correct-ido
    :ensure nil
    :after flyspell-correct
    :custom
    (flyspell-correct-interface #'flyspell-correct-ido "
  Explicitly set flyspell-correct to use the ido interface."))

  (use-package auto-dictionary
    :hook (flyspell-mode . auto-dictionary-mode))
#+END_SRC

* Programming
A little known fact. Occasionally, I use Emacs to program. Outrageous I know,
but it's true.

** Language Server
For any language I use, I try to leverage a Language Server if available. Using
a lang server simplifies the setup, and allows me to share one server
configuration across multiple editors. As long as the functionality is in the
server, I can guarantee it will be available in every editor I use. If no lang.
server is available, or if there is some functionality not available in the
lang. server, I will fall back to some sort of ~lang-mode~ package. Using both
is also a valid option, as long as they do not conflict or result in displaying
some chunks of information twice.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :hook (((java-mode dockerfile-mode go-mode) . lsp)
           (lsp-mode . lsp-enable-which-key-integration))
    :bind-keymap ("<localleader> l" . lsp-command-map)
    :custom
    (read-process-output-max (* 1024 1024))
    (lsp-idle-delay 0.500))
#+END_SRC

*** LSP UI
~lsp-ui~ gives much higher-level interactions with ~lsp-mode~:

- Doc :: Fetch documentation and display it in a popup buffer.
- Flycheck :: LSP interactions via Flycheck, like outputting the full list and
              navigating between info/warnings/errors.
- iMenu :: LSP interaction via ~imenu~.
- Peek :: Enable peeking & jumping to definitions.
- Sideline :: Display LSP actions and Flycheck output on the right-hand side of
              the buffer.

I deliberately disable the Doc functionality, as I find it intrusive. It also
sometimes renders with an incorrect size. Instead, I have a key binding to
enable/disable the Doc. The same goes for the ~imenu~ buffer.

I change the face for the peek references to match the Leuven ~org-block~
colours.

The Sideline is a feature that I used to also disable, but after tweaking it a
bit and removing the symbol information I find it very handy. The few tweaks I
make are changing the face to match the ~ol1~ face from Leuven theme, and adding
a prefix to the code actions panel. The only issue I still have with it is the
Flycheck diagnostic information for /info/ showing up as a hideously bright
green.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :after lsp
    :hook (lsp . lsp-ui-mode)
    :config
    (defun max/toggle-lsp-ui-doc ()
      "Toggle the UI Doc"
      (interactive)
      (if (lsp-ui-doc--visible-p)
          (lsp-ui-doc-hide)
        (lsp-ui-doc-show)))

    (defun max/toggle-lsp-ui-imenu ()
      "Toggle the ~lsp-ui~ ~imenu~ buffer."
      (interactive)
      (if (get-buffer "*lsp-ui-imenu*")
          (kill-buffer "*lsp-ui-imenu*")
        (lsp-ui-imenu)))

    :custom
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-ignore-duplicate t)
    (lsp-ui-flycheck-enable t)
    (lsp-ui-doc-enable nil) ; Disable the Docs by default

    :custom-face
    (lsp-ui-sideline-code-action ((t (
                                      :foreground "#3C3C3C"
                                      :background "#F0F0F0"))))

    (lsp-ui-peek-peek ((t (:background "#FFFFE0"))))
    (lsp-ui-peek-list ((t (:background "#FFFFE0"))))
    (lsp-ui-peek-filename ((t (
                               :foreground "#4183C4"
                               :background nil))))
    (lsp-ui-peek-highlight ((t (
                                :background "#F6FECD"
                                :slant italic))))
    (lsp-ui-peek-selection ((t (
                                :foreground "#333333"
                                :background "#F6FECD"))))
    (lsp-ui-peek-header ((t (
                             :underline "#A7A6AA"
                             :foreground "#555555"
                             :background "#E2E1D5"))))
    (lsp-ui-peek-footer ((t (
                             :underline "#A7A6AA"
                             :foreground "#555555"
                             :background "#E2E1D5")))))
#+END_SRC

** Flycheck
[[https://www.flycheck.org/en/latest/][Flycheck]] is a fantastic syntax checker and linter for Emacs. It has support for
most major programming languages (mostly) out-of-the-box, and ~lsp-mode~ has
built in support for Flycheck.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :custom
    ;; Disable flycheck on checkdoc
    (flycheck-emacs-lisp-initialize-packages t)
    (flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

** Compilation Buffer
The compilation buffer is a dumb terminal, which means it does not attempt to
escape ANSI codes. This result is cluttering the buffer with the ANSI colour
codes. Emacs can handle these colour codes, but it requires applying a function
against the entire buffers output.

#+BEGIN_SRC emacs-lisp
  (use-package compile
    :ensure nil
    :bind ("C-<f11>" . compile)
    :hook (compilation-filter . max-colorize-compilation-buffer)
    :commands ansi-color-apply-on-region
    :init
    (defun max-colorize-compilation-buffer ()
      (require 'ansi-color)
      (read-only-mode)
      (ansi-color-apply-on-region compilation-filter-start (point))))
#+END_SRC

** Programming & Markup Languages
The following are specific configurations for individual programming and markup
languages.

*** Docker
~~~
npm install --global dockerfile-language-server-nodejs
~~~

#+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :mode (("Dockerfile\\'" . dockerfile-mode)))
#+END_SRC

*** Clojure
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :mode ("\\.cl\\'" . clojure-mode)
    :hook max-clojure-mode-hook
    :init
    (defun max-clojure-mode-hook ()
      (make-local-variable 'company-backends)
      (set 'company-backends ())
      (add-to-list 'company-backends '(company-capf
                                       company-yasnippet
                                       company-files
                                       company-dabbrev-code))))

  (use-package cider
    :after clojure-mode)
#+END_SRC

*** Emacs Lisp
Elisp makes the (Emacs) world go round. Making your Elisp editing experience as
comfortable as possible is a must. Being able to whip around functions and
evaluate arbitrary code is a fabulous (and dangerous) power to wield.

#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :mode ("\\.el\\'" . emacs-lisp-mode)
    :interpreter ("emacs" . emacs-lisp-mode)
    :commands emacs-lisp-mode
    :hook (emacs-lisp-mode . max/elisp-mode-hook)
    :init
    (defun max/elisp-mode-hook ()
      (make-local-variable 'company-backends)
      (set 'company-backends ())
      (add-to-list 'company-backends '(company-capf
                                       company-yasnippet
                                       company-files
                                       company-dabbrev-code))))
#+END_SRC

IELM is an inferior Emacs Lisp mode that acts as a REPL for Elisp. REPL-driven
development for Lisp dialects is incredibly popular, and I want to hang with the
cool kids.

#+BEGIN_SRC emacs-lisp
  (use-package ielm
    :ensure nil
    :commands ielm
    :hook (ielm-mode . turn-on-eldoc-mode))
#+END_SRC

[[https://github.com/abo-abo/lispy][Lispy]] is a fantastic library that makes editing Elisp code so easy, even I can
do it. It provides interactions that are /"safe"/. That is to say, do not result
in non-executable Elisp. For example: deleting a line without dropping a
trailing parenthesis so the code is still valid. Another interaction includes
barfage and slurpage.

#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :hook (emacs-lisp-mode . lispy-mode))
#+END_SRC

Edebug is a source-level debugger for Elisp, same as you would find in any
fancy, 21st century IDE. But instead of needing a headless Eclipse instance, you
just need Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package edebug
    :ensure nil
    :commands edebug-defun
    :custom
    ;; Automatically to evaluate instrumentation required for Edebug.
    (edebug-all-defs t)
    ;; Display a trace of function calls in an external buffer.
    (edebug-trace t))
#+END_SRC

*** Golang
~~~
go get gopls
~~~

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :custom
    ;; Run goimports before saving a file
    (gofmt-command "goimports"))
#+END_SRC

*** Java
#+BEGIN_SRC emacs-lisp
  (use-package java-mode
    :mode "\\.java\\'"
    :ensure nil
    :commands java-mode)

  (use-package lsp-java
    :ensure t
    :after (java-mode lsp))
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    ;; Use GitHub markdown on README.md files, and regular Markdown on others
    :mode (("README\\.md'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)))
#+END_SRC

*** Typescript
#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'")

  (use-package json-mode
    :mode "\\.json\\'")
#+END_SRC

*** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'")
#+END_SRC

*** Shell Scripts
The built in ~sh-script~ mode paired with ~company-shell~ and Flycheck has been a
good experience. I find it better than using a language server. ~shfmt~ is a
source-code formatting tool similar to ~gofmt~. Formatting is something that I
should never be doing manually, and this tool makes it easy to automate
formatting.

#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :ensure nil
    :mode "\\.sh\\'"
    :hook (sh-mode . max-sh-mode-hook)
    :bind (:map sh-mode-map
           ("<localleader> c" . sh-case)
           ("<localleader> f" . sh-for)
           ("<localleader> F" . sh-function)
           ("<localleader> i" . sh-if)
           ("<localleader> I" . sh-indexed-loop)
           ("<localleader> r" . sh-repeat)
           ("<localleader> s" . sh-select)
           ("<localleader> u" . sh-until)
           ("<localleader> w" . sh-while)
           ("<localleader> W" . sh-while-getopts))
    :defines company-backends
    :functions sh-case
    :init
    (defun max-sh-mode-hook ()
      (make-local-variable 'company-backends)
      (set 'company-backends ())
      (add-to-list 'company-backends '(company-yasnippet
                                       company-shell
                                       company-shell-env
                                       company-files))))

  (use-package company-shell
    :after sh-script)

  (use-package shfmt
    :after sh-script
    :hook (sh-mode . shfmt-on-save-mode)
    :custom
    (shfmt-arguments '("-i" "2" "-ci") "
  A list of arguments passed to shfmt. -i 2 means indent by two spaces, and -ci
  indents case statements."))
#+END_SRC

* Org-mode
Org-mode was the killer feature that got me to try out Emacs to begin with, and
honestly it's probably the main reason I keep using Emacs.

I have tried multiple solutions to low tech or plain text note taking and
productivity tools, but until org-mode I was constantly disappointed. Todo.txt,
Markdown, XML with custom schemas, and Bullet Journals. Bullet Journals was the
closest to a perfect solution, but my natural tendency to forget my journal at
home lead to me dropping it as well.

Combining org-mode with Orgzly and Syncthing has become my perfect organization,
productivity, and note taking stack.

The location of my Org files differs depending on what machine I am on. On my
personal machine, the directory is ~/home/max/doc/org/~. I sync it with
Nextcloud as a backup solution, and synced to my mobile phone with Syncthing. On
my work machine, it is under ~C:\Users\maxwell.haley\Org~. The drive is
automatically up on some schedule, but it is not the most robust backup
solution. So, I have a Batch script that copies the contents of my Org directory
to my works network drive. Again this is not truly a backup solution, but the
network drive replicates on a much more regular basis. I have Task Scheduler run
this script when I log into my machine, every time I lock my machine, and every
night at 17:00.

#+BEGIN_SRC bat
    @echo off
    cd /D F:\Org
    xcopy C:\Users\maxwell.haley\Org\*.* /E /Q /Y
#+END_SRC

I treat all "to-do" items in Org Mode as tasks. A task is a to-do item that is,
in theory, ready for action. It must have a clear name, a description (if
required), an estimate, one or many context tags (as well as any other
appropriate tags), and a priority.

Estimates use the format ~HH:MM~, and represent how long I believe the task will
take. Anything greater than one day should instead be a project, and broken down
into smaller tasks. Context tags define where I will be able to action the task.
For example: ~@home~ means this task requires me to be at home in order to
complete it, ~@work~ means I must be at work, and ~@home:@work~ means I can be
either at home or at work. Priorities define how important it is I get to this
task. I follow a system that follows [[https://www.eisenhower.me/eisenhower-matrix/][the Eisenhower Matrix]]. They range from
priority /A/, to priority /D/.

- A :: Task completion is important and urgent. Action as soon as possible
- B :: Task completion is important, but not urgent. Plan when to action
- C :: Task is not important, but is urgent. Delegate if possible
- D :: Task is not important, and not urgent. File appropriately

Priority /D/ can mean either /"Someone has asked me to do something, but did not
give me a deadline or priority. So I am logging the request, but will not action
it until further discussions,"/ or /"This is a personal project/assignment and I
can chose to do it at my leisure"/. In any case, it should be clear which of the
two is applicable.

I keep three states for task to-do keywords:

1. Actionable
2. Blocked
3. Raw

The actionable is for tasks that are either ready for me to action, or are
currently actioned. The keywords are:

- TODO :: A task that is ready for action.

- IN-PROGRESS :: A task that I am actively working on.

- DONE :: A task that I have completed.

The blocked state are for tasks that I cannot actively begin to action or
continue actioning. The keywords are:

- WAITING :: I am waiting for another person to do something before I can
             continue this task (e.g., waiting on an email response, waiting for
             them to complete a task, waiting for more information, etc.)

- HOLD :: The task is now "on hold". Someone (myself included) has decided that
          while this task should get done, it needs to wait until some time in
          the future. Either new priorities have come up, the project has
          stalled, etc.

- DELEGATED :: I have delegated this task to another person, but I still need to
               oversee that it gets done.

- CANCELLED :: This task is no longer of any concern to me.

The last state has only one keyword: ~RAW~. A raw task mean it has not been
properly groomed. The task is just an idea that I must flesh out before I should
think about actioning it. Most newly captured tasks should be raw. Raw tasks
should never leave my Inbox file.

Another type of Org entry is a financial entry. These act as reminders to pay
one-time and re-occurring bills. Financial entries must have a deadline. I have
three states for these entries:

- EXPENSE :: This is an expense that I have yet to pay off.

- OVERDUE :: This is an expense that is past it's deadline, and I should be
             freaking out about it.

- PAID :: I have paid off this expense, and can sleep happy.

I use the ~PROJECT~ tag to indicate that all sub-headers are part of the same
overarching task defined in the tagged header. I make sure to exclude this tag
from the inheritance list so all sub-headers do not get the ~PROJECT~ tag.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :pin org
    :bind ((:map org-mode-map
                 ("<localleader> '"   . org-edit-special)
                 ("<localleader> :"   . org-set-tags-command)
                 ("<localleader> a"   . org-archive-subtree)
                 ("<localleader> c i" . org-clock-in)
                 ("<localleader> c o" . org-clock-out)
                 ("<localleader> C"   . org-ctrl-c-ctrl-c)
                 ("<localleader> d"   . org-deadline)
                 ("<localleader> e"   . org-export-dispatch)
                 ("<localleader> h i" . org-insert-heading-respect-content)
                 ("<localleader> h I" . org-insert-heading-after-current)
                 ("<localleader> h s" . org-insert-subheading)
                 ("<localleader> h s" . org-insert-subheading)
                 ("<localleader> o"   . org-open-at-point)
                 ("<localleader> r"   . org-refile)
                 ("<localleader> s"   . org-schedule))
           (:map org-src-mode-map
                 ("<localleader> '" . org-edit-src-exit)
                 ("<localleader> k" . org-edit-src-abort)))
    :defines company-backends
    :commands (org-update-all-dblocks org-emphasize)
    :functions (max-set-prettify-symbols max-set-company-backends)
    :init
    (defun max-org-update-dblocks ()
      "Wrapper around `org-update-all-dblocks' that only executes said function
  if the current buffer is an Org buffer. The intention is to call this function
  alongside hooks for automatic dynamic block updating."
      (interactive)
      (when (derived-mode-p 'org-mode)
        (org-update-all-dblocks)))

    (defun max-org-mode-hook ()
      "Wrapper for all functions that need to be hooked to Org mode."
      (set-fill-column 80)
      (display-fill-column-indicator-mode 0)
      (auto-fill-mode)
      (max-set-prettify-symbols '("#+BEGIN_SRC" . ?)
                                '("#+END_SRC" . ?)
                                '("#+begin_src" . ?)
                                '("#+end_src" . ?))
      (max-set-company-backends '(company-ispell company-yasnippet company-files)))

    :commands (org-mode org-capture org-agenda orgtbl-mode)
    :mode ("\\.org$" . org-mode)
    :hook ((before-save . max-org-update-dblocks)
           (org-mode . max-org-mode-hook))
    :config
    ;; I have two machines I use this Emacs configuration on. My personal laptop,
    ;; running Linux, and my work laptop, running Windows. The directories are
    ;; different between them, so I handle setting them here.
    (let* ((max/org-mode-root-directory
            (cond ((eq system-type 'gnu/linux)
                   "/home/max/doc/org")
                  ((or (eq system-type 'windows-nt) (eq system-type 'cygwin))
                   "C:/Users/maxwell.haley/Org")))

           (max/org-agenda-root-directory (concat
                                           max/org-mode-root-directory
                                           "/agenda"))
           (max/org-inbox-file (concat
                                max/org-agenda-root-directory
                                "/inbox.org"))
           (max/org-archive-location (concat
                                      max/org-agenda-root-directory
                                      "/archive.org::* Archives")))

      (setq org-directory          max/org-mode-root-directory
            org-agenda-files       (list max/org-agenda-root-directory)
            org-default-notes-file max/org-inbox-file
            org-archive-location   max/org-archive-location))

    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region
                                             (match-beginning 1)
                                             (match-end 1) ""))))))
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([+]\\) "
                               (0 (prog1 () (compose-region
                                             (match-beginning 1)
                                             (match-end 1) ""))))))

    ;; Functions to quickly emphasize a region.
    (defun max/org-bold-region ()
      (interactive)
      (org-emphasize ?\*))
    (defun max/org-code-region ()
      (interactive)
      (org-emphasize ?\~))
    (defun max/org-italic-region ()
      (interactive)
      (org-emphasize ?\/))
    (defun max/org-strike-through-region ()
      (interactive)
      (org-emphasize ?\+))
    (defun max/org-underline-region ()
      (interactive)
      (org-emphasize ?\_))
    (defun max/org-verbatim-region ()
      (interactive)
      (org-emphasize ?\=))

    (add-to-list 'org-modules 'org-habit)

    :custom
    (org-log-done 'time "Inserts a timestamp on task completion.")
    (org-log-into-drawer t)
    (org-use-fast-todo-selection t "Enable jumping to specific states.")
    (org-todo-keywords
     '((sequence "TODO(t)" "IN-PROGRESS(i)" "|" "DONE(d)")
       (sequence "RAW(-)" "WAITING(w@/!)" "HOLD(h@/!)" "DELEGATED(D)" "|" "CANCELLED(c@/!)")
       (sequence "EXPENSE(e)" "OVERDUE(o@/!)" "|" "PAID(p)")))
    (org-use-tag-inheritance t)
    (org-tag-alist '(("@home" . ?h)
                     ("@work" . ?w)
                     ("@daycare" . ?d)
                     ("PROJECT" . ?P)))
    (org-refile-use-outline-path t "
     Pick refile targets using paths. This works nicely with how I name bucket
     headlines for storing like tasks/notes.")
    (org-refile-targets '((org-agenda-files . (:maxlevel . 3))) "
  The refile targets are based off my agenda files, and only goes down three
  levels.")
    (org-fontify-done-headline t)
    (org-startup-indented t "Enable indent mode on all Org files.")
    (org-ellipsis " " "Use fancy symbol to represent headers with additional content.")
    (org-special-ctrl-a/e t
                          "When on a headline, treat anything after
  the stars and todo keyword as the beginning of the line and the
  character before the tags as the end of the line.")
    (org-confirm-babel-evaluate nil "Do not prompt on source block evaluations.")
    (org-src-window-setup 'current-window "
     Open source code block windows on top of the current window instead of
     opening  new window. This stops editing source blocks from ruining your
     window setup."))
   #+END_SRC

   Org-bullets changes out the asterisks for UTF-8 symbols.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
     :hook (org-mode . evil-org-mode)
     :commands evil-org-set-key-theme
     :functions evil-org-agenda-set-keys
     :config
     (require 'evil-org-agenda)
     (evil-org-set-key-theme)
     (evil-org-set-key-theme '(return
                               navigation
                               textobjects
                               calendar
                               additional
                               shift
                               todo))
     (evil-org-agenda-set-keys))
#+END_SRC

** Capture
Org-capture is a fantastic feature I wish I used more often. Most of the time
when capturing would be useful I'm away from my laptop. I use Orgzly's quick
note feature to accomplish a similar result, but the options for /how/ to
capture the information is far more limited than org-capture proper.

That said, setting up capture templates for my work machine would probably be a
blessing. I'm on that thing 7.5 hours a day.

I define all templates externally in ~*.txt~ files to keep this configuration
file clean. The goal of each template is to capture the minimum amount of
information required for the item to be actionable (excluding the ~RAW~
capture). These are my templates:

- Task :: Capture a ready to action entry. I should be able to fill in all the
          criteria of a task whenever capturing something using this template.
          If anything is unclear, I should be using a raw task.

- Raw task :: A task that requires further fleshing out, or that I require far
              more information on. Raw tasks are not to leave my inbox.

- Note :: A name, timestamp, content. Just a note

- Org Protocol :: Used when capturing a web page via ~org-protocol~. Could
                  become a note, a task, or something else entirely. I invoke
                  Org protocol using the following bookmark:

#+BEGIN_SRC javascript
  javascript:location.href='org-protocol://capture?template=p&url='+encodeURIComponent(location.href)
      + '&title='+encodeURIComponent(document.title)
      + '&body='+encodeURIComponent(window.getSelection())
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org-protocol
    :ensure nil
    :after org-capture)
#+END_SRC

- Journal entry :: An entry into my personal journal. It invokes the function
                   ~max/journal-capture~ to handle creating the correct
                   month/week headers automatically.


#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :ensure nil
    :bind ("<leader> o c" . org-capture)
    :commands org-find-olp
    :config
    (defun max-journal-capture ()
      "Sets the pointer to the correct Month/Week location in my journal file.
  If the week or month does not exist, it is automatically
  inserted."
      (require 'org)
      (let ((month (format-time-string "%B"))
            (week (format-time-string "W%V")))
        (unless (search-forward (format "* %s" month) nil t)
          (goto-char (point-max))
          (insert (format "* %s\n** %s\n" month week)))
        (goto-char (point-max))
        (unless (search-backward (format "** %s" week) nil t)
          (insert (format "** %s\n" week)))
        (goto-char (org-find-olp (list month week) t)) t))

    (defun max-note-capture ()
      "Create a new Org file based on a prompted description.
  The title and first-level heading values uses the description,
  and converts them to snake case for the file name. Drops the
  pointer at the end of the new file for Org Capture to start off
  on."
      (let* ((note-desc
              (read-string "Enter a brief description of the note: "))
             (note-file-name
              (replace-regexp-in-string " " "-" (downcase note-desc))))
        (find-file (concat "~/doc/org/" note-file-name ".org"))
        (goto-char (point-min))
        (insert
         (format "#+TITLE: %s\n" note-desc)
         (format "* %s :note:\n" note-desc))
        (goto-char (point-max))))

    :custom
    (org-capture-templates
     '(("t" "Task" entry (file "~/doc/org/agenda/inbox.org")
        (file "~/.config/emacs/capture-templates/task.txt"))
       ("T" "Raw task" entry (file "~/doc/org/agenda/inbox.org")
        (file "~/.config/emacs/capture-templates/raw-task.txt"))
       ("n" "Note" plain (function max-note-capture)
        (file "~/.config/emacs/capture-templates/note.txt"))
       ("j" "Journal Entry" entry (file+function "~/doc/org/journal.org" max-journal-capture)
        (file "~/.config/emacs/capture-templates/journal-entry.txt"))
       ("p" "Org Protocol Capture" entry (file "~/doc/org/agenda/inbox.org")
        (file "~/.config/emacs/capture-templates/protocol.txt")))))
#+END_SRC

** Agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :ensure nil
    :bind ("<leader> o" . org-agenda)
    :functions (org-end-of-subtree org-entry-get)
    :config
    (display-fill-column-indicator-mode 0)

    (defun max/org-skip-subtree-if-habit ()
      "Skip an agenda entry if it has a STYLE property equal to \"habit\".

  From https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html"
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (string= (org-entry-get nil "STYLE") "habit")
            subtree-end
          nil)))

    (defun max/org-skip-subtree-if-not-habit ()
      "Skip an agenda entry if it has a STYLE property not equal to \"habit\".

  From https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html"
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (not (string= (org-entry-get nil "STYLE") "habit"))
            subtree-end
          nil)))

    :custom
    (org-agenda-span 3 "
      By default, show today and the next two days when opening the agenda.
      When planning ahead, three days is usually good enough to see if I'm
      overworking myself.")
    (org-agenda-tags-column -100 "
      Pushes off the tags if I'm viewing the agenda in a vertical split on the
      laptop. I'd rather see the content of the heading rather than the tags
      associated in most contexts.")
    (org-agenda-block-separator "")
    (org-agenda-custom-commands '(("r" "Raw tasks"
                                   ((todo "RAW"
                                          ((org-agenda-overriding-header
                                            "Unprocessed tasks:")))))
                                  ("d" "Daily agenda"
                                   ((tags "PRIORITY=\"A\""
                                          ((org-agenda-skip-function
                                            '(org-agenda-skip-entry-if
                                              'todo
                                              'done))
                                           (org-agenda-files
                                            '("~/doc/org/agenda/todo.org"))
                                           (org-agenda-overriding-header
                                            "High-priority tasks:")))
                                    (agenda ""
                                            ((org-agenda-span 1)
                                             (org-agenda-skip-function
                                              '(max/org-skip-subtree-if-not-habit))
                                             (org-agenda-overriding-header
                                              "Todays habits:")))
                                    (agenda ""
                                            ((org-agenda-span 1)
                                             (org-agenda-skip-function
                                              '(max/org-skip-subtree-if-habit))
                                             (org-agenda-overriding-header
                                              "Todays tasks:")))
                                    (alltodo ""
                                             ((org-agenda-files
                                               '("~/doc/org/agenda/someday.org"))
                                              (org-agenda-overriding-header
                                               "Other tasks:")))))
                                  ("w" "Weekly agenda"
                                   ((agenda ""
                                            ((org-agenda-span 7)
                                             (org-agenda-overriding-header
                                              "Weekly agenda:")))))
                                  ("p" "Projects"
                                   ((tags "+PROJECT"
                                         ((org-agenda-files
                                           '("~/doc/org/agenda/projects.org"))
                                          (org-tags-match-list-sublevels t)
                                          (org-agenda-overriding-header
                                           "Projects:"))))))))
#+END_SRC

** Cliplink
[[https://github.com/rexim/org-cliplink][Org-cliplink]] grabs a URL from the clipboard, fetches the title of the web page,
then inserts a link element with the URL as the link and the title as the
description. I use this over ~org-protocol~ when I only want to use the web page
as a reference point and not as an entry.

#+BEGIN_SRC emacs-lisp
  (use-package org-cliplink
    :bind (:map org-mode-map
           ("<localleader> L" . org-cliplink))
    :ensure t
    :after org)
#+END_SRC

** Deft
Deft is a mode that allows dynamic filtering of plaint-text files. I use it
quickly search through my Org notes. I can enter a fuzzy term like "git" and get
back every file that mentions Git.

#+BEGIN_SRC emacs-lisp
  (use-package deft
    :disabled t
    :custom
    (deft-extentions '("org"))
    (deft-directory "~/doc/org/"))
#+END_SRC

** Confluence Markup Export
We use Jira/Confluence at work. I prefer writing up my notes in Org mode, but in
the end they need to be on Confluence. ~ox-jira~ lets me export my Org notes as
Confluence friendly markup. This includes properly generating source blocks,
which is just the best.

#+BEGIN_SRC emacs-lisp
  (use-package ox-jira
    :after org)
#+END_SRC

** Writegood Mode
I'm not a regular writer, so I often fall into pitfalls. Relying too much on
[[https://en.wikipedia.org/wiki/Weasel_word][weasel words]], or accidentally writing something in the wrong tense.
[[https://github.com/bnbeckwith/writegood-mode][Writegood-mode]] is a fantastic library for someone who is not used to the
challenges of writing. It highlights those weasel words that sneak up on you,
duplicate words, and it highlights phrases that are in the passive voice.

   #+BEGIN_SRC emacs-lisp
     (use-package writegood-mode
       :hook (org-mode markdown-mode latex-mode text-mode)
       :custom-face
       ;; Inherits the ~flyspell-duplicate~ face from Leuven theme
       (writegood-duplicates-face ((t (:inherit flyspell-duplicate))))

       ;; Uses the same colour as the foreground of second level outlines in Org mode
       ;; as defined within Leuven theme.
       (writegood-passive-voice-face ((t (:underline (:style wave :color "#123555"))))))
   #+END_SRC

** Habits
#+BEGIN_SRC emacs-lisp
  (use-package org-habit
    :ensure nil
    :after org
    :custom
    (org-habit-graph-column 66)
    (org-habit-preceding-days 7))
#+END_SRC

