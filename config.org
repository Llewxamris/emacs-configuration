#+TITLE: Maxwell Haley's Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#  LocalWords:  Leuven Flycheck

* Forward
	My living monolith of a Emacs configuration file. Bred through trial, error, and
	peeking at the configurations of people far more wise than I. Here's a list
	of some of those configurations I've lifted. Can't let me get away red handed.

	- [[https://github.com/angrybacon/dotemacs][angrybacon/dotemacs]]
	- [[https://github.com/valignatev/dotfiles][valignatev/dotfiles]]
	- [[https://github.com/sachac/.emacs.d][sachac/.emacs.d]]
	- [[https://github.com/wasamasa/dotemacs][wasamasa/dotemacs]]

	The entire configuration file is written out in Emac's Org Mode. The goal is to
	describe and justify my decisions in a way that both:

	1. Anyone interested in building their own configuration can browse through my
	own and make informed decisions on what they want to co-opt
	2. I can figure out /"What the f--- was I thinking."/ in the next few months

	I also tried to use some humour to make reading through this YAML file on
	steroids enjoyable. I apologize in advance.

  To start of this configuration, lets define my name and email address before
	kicking off the package initialization.

	#+BEGIN_SRC emacs-lisp
	(setq user-full-name "Maxwell R. Haley")
	(setq user-mail-address "maxwell.r.haley@gmail.com")
	(package-initialize)
	#+END_SRC

* Preparation & Package Management
** Custom
	 Hide away the ~custom~ configurations. I try to avoid using ~custom~ in
	 general. I find figuring out how to do it manually much more +infuriating+
	 entertaining.

	 #+BEGIN_SRC emacs-lisp
		 (setq custom-file (concat user-emacs-directory ".custom.el"))
		 (load custom-file t)
	 #+END_SRC

** Remote Package Archives
	 Define what remote archives to use as package repositories. GNU ELPA is the
	 default package repository for Emacs. It is a solid repository, but limited
	 in content. MELPA has a much larger selection of modern and up-to-date packages.

	 Org is the Org mode repository.

	 #+BEGIN_SRC emacs-lisp
		 (setq package-archives '(("melpa" . "http://melpa.milkbox.net/packages/")
															("org" . "http://orgmode.org/elpa/")
															("gnu" . "http://elpa.gnu.org/packages/")))
	 #+END_SRC

** Use Package
   Check the package directory for manually installed packages.

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (defvar package-dir (expand-file-name "packages" user-emacs-directory)
         "The packages directory")
       (add-to-list 'load-path package-dir))
   #+END_SRC

	 /Ensure/ ~use-package~ is always installed alongside this configuration. I /ensure/
	 to always /ensure/ my packages are available, and then /ensure/ I have the
	 newest packages available.

	 Also included is ~auto-package-update~. It automatically updates packages seven
	 days after the previous upgrade was ran.

	 #+BEGIN_SRC emacs-lisp
		 (unless (package-installed-p 'use-package)
			 (package-refresh-contents)
			 (package-install 'use-package))
		 (require 'use-package)
		 (setq use-package-verbose t)
		 (setq use-package-always-ensure t)
		 (setq load-prefer-newer t)

		 (use-package auto-package-update
			 :config
			 (setq auto-package-update-delete-old-versions t)
			 (setq auto-package-update-hide-results t)
			 (auto-package-update-maybe))
	 #+END_SRC

** General
	 I prefer defining keys using the [[https://github.com/noctuid/general.el][General]] syntactic sugar style. It interops
	 extremely well with Evil, and makes it absurdly easy to use mnemonic style
	 motions. To demonstrate, behold my help binds!

*** Help Keybinds
     | Keybind   | Command           | Description                                |
     |-----------+-------------------+--------------------------------------------|
     | SPC h d f | describe-function | Look up the definition of a function.      |
     | SPC h d k | describe-key      | Look up the function invoked by the        |
     |           |                   | given key.                                 |
     | SPC h d m | describe-mode     | Displays the documentation for the current |
     |           |                   | major and minor modes.                     |
     | SPC h d s | describe-symbol   | Look up the definition of a symbol.        |
     | SPC h d v | describe-variable | Look up the definition and value of a      |
     |           |                   | variable.                                  |

		#+BEGIN_SRC emacs-lisp
			(use-package general
				:config
				(general-define-key
				 :states 'normal
				 :prefix "SPC h d"
				 "f" 'describe-function
				 "k" 'describe-key
				 "m" 'describe-mode
				 "s" 'describe-symbol
				 "v" 'describe-variable))
		#+END_SRC

** Automatically Byte Compile Emacs Lisp Libraries
	 Byte compiling Emacs Lisp files allows them to load and execute faster. I've
	 never tested the speed difference of compiled vs. not-compiled, but I assume
	 the performance increase over time is negated by the amount of time spent
	 setting up my Emacs configuration.

	 #+BEGIN_SRC emacs-lisp
			(use-package auto-compile
				:config
					;; Auto-compile on both loading and saving.
					(auto-compile-on-load-mode)
					(auto-compile-on-save-mode))
	 #+END_SRC

** Reload Configuration
	 The following function definition allows me to reload my Emacs configuration
	 on the fly.

	 #+BEGIN_SRC emacs-lisp
		 (defun max/reload-emacs-configuration ()
			 (interactive)
			 (load-file (concat user-emacs-directory "init.el")))
	 #+END_SRC

*** Reload Keybinds
     | Keybind   | Command                        | Description                        |
     |-----------+--------------------------------+------------------------------------|
     | SPC f e R | max/reload-emacs-configuration | Reload my Emacs configuration file |

	 #+BEGIN_SRC emacs-lisp
	   (general-define-key
		  :states 'normal
		  :prefix "SPC f e"
		  "R" 'max/reload-emacs-configuration)
	 #+END_SRC

* Look & Feel
** Emacs Essentials
	 Disable the startup screen & message.

	 #+BEGIN_SRC emacs-lisp
		(setq inhibit-splash-screen t)
		(setq	inhibit-startup-echo-area-message t)
		(setq	inhibit-startup-message t)
	 #+END_SRC

	 Disable the bell that makes me feel shame every time it lets me know I fumbled a
	 keystroke. Worse, its almost like hearing the bell guarantees the next
	 few strokes will also be fumbled resulting in more bells. Disable this
	 existential horror please.

	 #+BEGIN_SRC emacs-lisp
	(setq ring-bell-function 'ignore) ; *ding-ding* SHAME. *ding-ding* SHAME.
	 #+END_SRC

	 Seeing three bars on a slot machine is good. Seeing three bars on Emacs is bad.

	 #+BEGIN_SRC emacs-lisp
		(menu-bar-mode -1)
		(scroll-bar-mode -1)
		(tool-bar-mode -1)
	 #+END_SRC

	 Force syntax highlighting for all supported major modes.

	 #+BEGIN_SRC emacs-lisp
		(global-font-lock-mode t)
	 #+END_SRC

	 Change the "Yes or No" prompt to just be "y or n".

	 #+BEGIN_SRC emacs-lisp
		 (defalias 'yes-or-no-p 'y-or-n-p)
	 #+END_SRC

	 Show keystrokes after 0.1 seconds. Any longer and the panic sets in.
	 Similarly, I like having which-key around to pat me on the back and tell
	 me I'm doing okay when I start a motion and forget where to go next.

	 #+BEGIN_SRC emacs-lisp
		 (setq echo-keystrokes 0.01)

		 (use-package which-key
			 :hook (after-init . which-key-mode))
	 #+END_SRC

	 Show column numbers on the modeline.

	 #+BEGIN_SRC emacs-lisp
		 (column-number-mode t)
	 #+END_SRC

	 Show the size of the current buffer in the modeline.

	 #+BEGIN_SRC emacs-lisp
		 (size-indication-mode)
	 #+END_SRC

	 Automatically decompress archives when reading, and then compress again when
	 writing.

	 #+BEGIN_SRC emacs-lisp
	(auto-compression-mode t)
	 #+END_SRC

	 If the cursor is on the end of a line, stay on the end of the line when
	 moving to the next or previous line.

	 #+BEGIN_SRC emacs-lisp
	(setq track-eol t)
	 #+END_SRC

*** Essential Keybinds
		| Keybind | Command                    | Description                                   |
		|---------+----------------------------+-----------------------------------------------|
		| SPC q q | save-buffers-kill-terminal | Prompt to save all buffers, then close Emacs. |
		| SPC f r |                            |                                               |

	 #+BEGIN_SRC emacs-lisp
		 (general-define-key
			:states 'normal
			:prefix "SPC q"
			"q" 'save-buffers-kill-terminal)
	 #+END_SRC

    | Keybind | Command     | Description                           |
    |---------+-------------+---------------------------------------|
    | SPC f r | save-buffer | Save the currently focused buffer.    |
    | SPC f w | find-file   | Navigate to a file via a tab-complete |
    |         |             | path editor.                          |

	 #+BEGIN_SRC emacs-lisp
		 (general-define-key
			:states 'normal
			:prefix "SPC f"
			"w" 'save-buffer
			"r" 'find-file)
	 #+END_SRC

    | Keybind | Command    | Description                                     |
    |---------+------------+-------------------------------------------------|
    | SPC b d | dired      | Prompt for a path, and open Dired at that path. |
    | SPC b D | dired-jump | Opens Dired in the directory of the currently   |
    |         |            | focused buffer.                                 |

		 #+BEGIN_SRC emacs-lisp
			 (general-define-key
				:states 'normal
				:prefix "SPC b"
				"d" 'dired
				"D" 'dired-jump)
		 #+END_SRC

** Backups & History
   Emacs auto-backups files, which is great. But, it dumps them in the current
   directory, which is terrible. Instead, dump them into ~.emacs.d/~.

   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
   #+END_SRC

	 I don't want to have my hard drive littered with backups, so I set Emacs to
	 only keep up to three backup versions. I also don't want to have a nag every
	 time it wants to delete a backup. I also include version controlled files,
	 just in case.

	 #+BEGIN_SRC emacs-lisp
		 (setq version-control t)
		 (setq kept-old-versions 3)
		 (setq delete-old-versions t)
		 (setq vc-make-backup-files t)
	 #+END_SRC

	 I also want to backup all of the commands I've used, so I can re-invoke them
   in later sessions. Command history is essential for any command based environment.

	 #+BEGIN_SRC emacs-lisp
		 (use-package savehist
			 :init
			 (setq savehist-file "~/.emacs.d/savehist")
			 (setq savehist-save-minibuffer-history +1)
			 (setq savehist-additional-variables
						 '(kill-ring
							 search-ring
							 regexp-search-ring))
			 :config
			 (savehist-mode))
	 #+END_SRC

** Editor
*** Character Encoding & General Formatting
		Set the current font to [[https://typeof.net/Iosevka/][Iosevka Term SS04]] with a size of 11.

		#+BEGIN_SRC emacs-lisp
			(add-to-list 'default-frame-alist '(font . "Iosevka Term SS04-11"))
		#+END_SRC

		Use UTF-8 encoding everywhere. I rarely run Emacs in a terminal, and even then
		my terminal of choice also supports UTF-8. No reason to not enable.

		#+BEGIN_SRC emacs-lisp
			(setq locale-coding-system 'utf-8)
			(set-terminal-coding-system 'utf-8)
			(set-keyboard-coding-system 'utf-8)
			(set-selection-coding-system 'utf-8)
			(prefer-coding-system 'utf-8)
		#+END_SRC

		To congratulate myself for taking a stand against non-UTF-8 encoding, I will
		reward myself some pretty symbols.

		#+BEGIN_SRC emacs-lisp
			(use-package pretty-mode
				:config
				(global-pretty-mode t))
		#+END_SRC

		Always include a trailing newline at the end of a file. As well, disable
		sentences ending with a double space. I don't think I've ever seen someone
		do this in real life, and to be frank I don't think I want to meet the people
		that do.

		#+BEGIN_SRC emacs-lisp
			(setq sentence-end-double-space nil)
			(setq require-final-newline t)
		#+END_SRC

		Use spaces instead of tabs.
		There must be a better way of doing this, /but I sure as hell can't find
		it!/

		#+BEGIN_SRC emacs-lisp
			(setq-default tab-width 2)
			(setq-default tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80))
			(setq indent-tabs-mode nil)
		#+END_SRC

		Automatically insert a closing symbol if an opening symbol is entered
		(paren., bracket, brace, etc.). The closing symbol is after the point
		of the cursor, so I can keep typing without having to adjust to the
		newly entered text.

		#+BEGIN_SRC emacs-lisp
			(electric-pair-mode)
		#+END_SRC

*** Colour Theme
		I've recently switched over to the [[https://github.com/fniessen/emacs-leuven-theme][Leuven]] theme. I've started switching
		over to light-themes for my systems in general. I keep my brightness
		relatively low, so dark-themes end up having poor contrast. Leuven
		was built with Org-mode in mind, and gives Org files a more cohesive
		feeling.

		#+BEGIN_SRC emacs-lisp
			(use-package leuven-theme
				:config
				;; Load the theme unless running without an interactive terminal.
				(unless noninteractive
					(load-theme 'leuven t)))
		#+END_SRC

*** Columns
		Always show the current line number and column number
		in the buffer. When both enabled, they appear like this:
		~~~
		(line, col)
		~~~

		#+BEGIN_SRC emacs-lisp
		 (setq line-number-mode t)
		 (setq column-number-mode t)
		#+END_SRC

		Visually wrap lines when they get too close to the fringe. Adds some curly
		arrows to help show which lines are being effected.

		#+BEGIN_SRC emacs-lisp
		 (global-visual-line-mode 1)
		 (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
		#+END_SRC

*** Rows
		Highlight the row the cursor is currently on.

		#+BEGIN_SRC emacs-lisp
			(global-hl-line-mode t)
		#+END_SRC

*** Parenthesis
		When the cursor is over a parenthesis, highlight all of the content between
		that parenthesis and it's matching opening/closing parenthesis. This is
		mostly useful when working with Lisp, but I have found it helpful in other
		situations as well. So I set it globally.

		#+BEGIN_SRC emacs-lisp
			(show-paren-mode t)
			(setq show-paren-style 'expression)
			(setq show-paren-delay 0)
		#+END_SRC

*** Doom Modeline
		A """minimalist""" modeline. It's minimalist, so that justifies satisfying
		my need for fancy colours and icons everywhere I look so I can keep my ADD
		rattled brain distracted while the rest of me tries to do real work.

		#+BEGIN_SRC emacs-lisp
			(use-package doom-modeline
				:hook (after-init . doom-modeline-mode))

			(use-package all-the-icons)
		#+END_SRC

*** Relative Line Numbering
		I really like Vims relative line number feature. I find it makes taking
		advantage of motions easier since it removes any sort of mental math. I
		use the [[https://github.com/coldnew/linum-relative][linum-relative]] package for this.

		#+BEGIN_SRC emacs-lisp
			(use-package linum-relative
				:init
				;; ~display-line-numbers-mode~ is the faster backend on Emacs 26
				(setq linum-relative-backend 'diplay-line-numbers-mode)
				:config
				(linum-relative-global-mode 1))
		#+END_SRC

*** Smooth Scrolling
		Leaves just a bit of room at the bottom and top of the window when
		scrolling. Something about it just feels so right. Uses the
		[[https://github.com/aspiers/smooth-scrolling][smooth-scrolling package]] .

		#+BEGIN_SRC emacs-lisp
			(use-package smooth-scrolling
				:config
				(smooth-scrolling-mode 1))
		#+END_SRC

** Autorevert
	 Automatically refresh buffers. That is: If the content of a buffer changes
	 (such as a file changing on disk), then redraw the buffer. I also set it
	 to refresh non-file buffers (such as Dired buffers), and to suppress the
	 nag.

	 #+BEGIN_SRC emacs-lisp
		 (use-package autorevert
			 :init
			 (setq global-auto-revert-non-file-buffers t)
			 (setq auto-revert-verbose nil)
			 :config
			 (global-auto-revert-mode t))
	 #+END_SRC

** Autosave
	 Automatically save buffers when focus changes or frames are deleted. Prevent
	 sudden crashes or battery deaths from losing data.

	 #+BEGIN_SRC emacs-lisp
		 (add-hook 'focus-out-hook (lambda () (interactive) (save-some-buffers t)))
		 (add-hook 'delete-frame-functions (lambda ()
																				 (interactive) (save-some-buffers t)))
	 #+END_SRC

** Window Management
	 Undo/Redo window layouts using C-c <left> and C-c <right>. Lets me fix
	 accidental destruction the layout of windows and buffers.

	 #+BEGIN_SRC emacs-lisp
		 (use-package winner
			 :config
			 (winner-mode 1))
	 #+END_SRC

*** Window Management Keybinds
    | Keybind   | Command                   | Description                                     |
    |-----------+---------------------------+-------------------------------------------------|
    | SPC w d   | delete-window             | Delete (close) the currently focused window.    |
    | SPC w h   | evil-window-left          | Focus the window to the left.                   |
    | SPC w j   | evil-window-bottom        | Focus the window below.                         |
    | SPC w k   | evil-window-up            | Focus the window above.                         |
    | SPC w l   | evil-window-right         | Focus the window to the right.                  |
    | SPC w s h | split-window-vertically   | Split the window, resulting in two vertically  |
    |           |                           | side-by-side windows.                           |
    | SPC w s v | split-window-horizontally | Split the window, resulting in two horizontally |
    |           |                           | side-by-side windows.                           |

	 #+BEGIN_SRC emacs-lisp
		 (general-define-key
			:states 'normal
			:prefix "SPC w"
			"d" 'delete-window
			"h" 'evil-window-left
			"j" 'evil-window-down
			"k" 'evil-window-up
			"l" 'evil-window-right
			"s h" 'split-window-vertically
			"s v" 'split-window-horizontally)
	 #+END_SRC

* Evil Mode
	Vim has the superior input style. There. I said it. Modal-based bindings flow so much
  better for me, both in thinking and in executing. Using Emacs native modifier bindings
  feels incredibly restrictive in comparison. My left hand needs to positioned to always
  be able to hold down Control, Alt, or Meta. Making my pinky the main work-horse of
  my typing, to me, feels like a terrible mistake. On the other hand, modal style editing
	lets me use my fingers equally. Even when I need to use some sort of modifier key (mostly
  the space bar), it ends up being my thumb doing the work. My thumb can withstand the
  brute force of slamming it down in frustration during a heated moment. My pinky is
  barely even an appendage.

	Evil mode gives me Vim-like keybindings without having to invest in any sort of
  remapping. I, of course, still add my own mappings and remappings. Not because Vim
  lacks anything, but entirely due to personal preference. Without Evil, I don't think
  I could see myself ever using Emacs seriously.

	#+BEGIN_SRC emacs-lisp
		(use-package evil
			:config
			(evil-mode 1))
	(use-package evil-commentary
			:ensure t
			:config
			(progn
				;; Enable by default
				(evil-commentary-mode)))
  #+END_SRC

* iBuffer
	iBuffer is a great tool for managing the many buffers created in day-to-day
	Emacs use.

	#+BEGIN_SRC emacs-lisp
		(use-package ibuffer
			:config
			(evil-set-initial-state 'ibuffer-mode 'normal))
	#+END_SRC
** iBuffer Keybinds
    | Keybind | Command | Description               |
    |---------+---------+---------------------------|
    | SPC b b | ibuffer | Open the iBuffer...buffer |

		 #+BEGIN_SRC emacs-lisp
			 (general-define-key
				:states 'normal
				:prefix "SPC b"
				"b" 'ibuffer)
		 #+END_SRC

		 #+BEGIN_SRC emacs-lisp
			 (general-define-key
				:states 'normal
				:keymaps 'ibuffer-mode-map
				"j" 'evil-next-line
				"k" 'evil-previous-line
				"l" 'ibuffer-visit-buffer
				"v" 'ibuffer-toggle-marks
				"m" 'ibuffer-mark-forward
				"u" 'ibuffer-unmark-forward
				"=" 'ibuffer-diff-with-file
				"J" 'ibuffer-jump-to-buffer
				"M-g" 'ibuffer-jump-to-buffer
				"M-s a C-s" 'ibuffer-do-isearch
				"M-s a M-C-s" 'ibuffer-do-isearch-regexp
				"M-s a C-o" 'ibuffer-do-occur
				"DEL" 'ibuffer-unmark-backward
				"M-DEL" 'ibuffer-unmark-all
				"* *" 'ibuffer-unmark-all
				"* M" 'ibuffer-mark-by-mode
				"* m" 'ibuffer-mark-modified-buffers
				"* u" 'ibuffer-mark-unsaved-buffers
				"* s" 'ibuffer-mark-special-buffers
				"* r" 'ibuffer-mark-read-only-buffers
				"* /" 'ibuffer-mark-dired-buffers
				"* e" 'ibuffer-mark-dissociated-buffers
				"* h" 'ibuffer-mark-help-buffers
				"* z" 'ibuffer-mark-compressed-file-buffers
				"." 'ibuffer-mark-old-buffers

				"d" 'ibuffer-mark-for-delete
				"C-d" 'ibuffer-mark-for-delete-backwards
				"x" 'ibuffer-do-kill-on-deletion-marks

				;; immediate operations
				"n" 'ibuffer-forward-line
				"SPC" 'forward-line
				"p" 'ibuffer-backward-line
				"M-}" 'ibuffer-forward-next-marked
				"M-{" 'ibuffer-backwards-next-marked
				"g" 'ibuffer-update
				"," 'ibuffer-toggle-sorting-mode
				"s i" 'ibuffer-invert-sorting
				"s a" 'ibuffer-do-sort-by-alphabetic
				"s v" 'ibuffer-do-sort-by-recency
				"s s" 'ibuffer-do-sort-by-size
				"s f" 'ibuffer-do-sort-by-filename/process
				"s m" 'ibuffer-do-sort-by-major-mode

				"/ m" 'ibuffer-filter-by-used-mode
				"/ M" 'ibuffer-filter-by-derived-mode
				"/ n" 'ibuffer-filter-by-name
				"/ c" 'ibuffer-filter-by-content
				"/ e" 'ibuffer-filter-by-predicate
				"/ f" 'ibuffer-filter-by-filename
				"/ >" 'ibuffer-filter-by-size-gt
				"/ <" 'ibuffer-filter-by-size-lt
				"/ r" 'ibuffer-switch-to-saved-filters
				"/ a" 'ibuffer-add-saved-filters
				"/ x" 'ibuffer-delete-saved-filters
				"/ d" 'ibuffer-decompose-filter
				"/ s" 'ibuffer-save-filters
				"/ p" 'ibuffer-pop-filter
				"/ !" 'ibuffer-negate-filter
				"/ t" 'ibuffer-exchange-filters
				"/ TAB" 'ibuffer-exchange-filters
				"/ o" 'ibuffer-or-filter
				"/ g" 'ibuffer-filters-to-filter-group
				"/ P" 'ibuffer-pop-filter-group
				"/ D" 'ibuffer-decompose-filter-group
				"/ /" 'ibuffer-filter-disable

				"M-n" 'ibuffer-forward-filter-group
				"\t" 'ibuffer-forward-filter-group
				"M-p" 'ibuffer-backward-filter-group
				[backtab] 'ibuffer-backward-filter-group
				"M-j" 'ibuffer-jump-to-filter-group
				"C-k" 'ibuffer-kill-line
				"C-y" 'ibuffer-yank
				"/ S" 'ibuffer-save-filter-groups
				"/ R" 'ibuffer-switch-to-saved-filter-groups
				"/ X" 'ibuffer-delete-saved-filter-groups
				"/ \\" 'ibuffer-clear-filter-groups

				"% n" 'ibuffer-mark-by-name-regexp
				"% m" 'ibuffer-mark-by-mode-regexp
				"% f" 'ibuffer-mark-by-file-name-regexp

				"C-t" 'ibuffer-visit-tags-table

				"|" 'ibuffer-do-shell-command-pipe
				"!" 'ibuffer-do-shell-command-file
				"~" 'ibuffer-do-toggle-modified
				"A" 'ibuffer-do-view
				"D" 'ibuffer-do-delete
				"E" 'ibuffer-do-eval
				"F" 'ibuffer-do-shell-command-file
				"I" 'ibuffer-do-query-replace-regexp
				"H" 'ibuffer-do-view-other-frame
				"N" 'ibuffer-do-shell-command-pipe-replace
				"M" 'ibuffer-do-toggle-modified
				"O" 'ibuffer-do-occur
				"P" 'ibuffer-do-print
				"Q" 'ibuffer-do-query-replace
				"R" 'ibuffer-do-rename-uniquely
				"S" 'ibuffer-do-save
				"T" 'ibuffer-do-toggle-read-only
				"U" 'ibuffer-do-replace-regexp
				"V" 'ibuffer-do-revert
				"W" 'ibuffer-do-view-and-eval
				"X" 'ibuffer-do-shell-command-pipe

				"w" 'ibuffer-copy-filename-as-kill

				"e" 'ibuffer-visit-buffer
				"f" 'ibuffer-visit-buffer
				"C-x C-f" 'ibuffer-find-file
				"o" 'ibuffer-visit-buffer-other-window
				"C-o" 'ibuffer-visit-buffer-other-window-noselect
				"M-o" 'ibuffer-visit-buffer-1-window
				"C-x v" 'ibuffer-do-view-horizontally
				"C-c C-a" 'ibuffer-auto-mode
				"C-x 4 RET" 'ibuffer-visit-buffer-other-window
				"C-x 5 RET" 'ibuffer-visit-buffer-other-frame)
		 #+END_SRC
* Dired-X
  Dired-X is the extended version of the Emacs file manager Dired. I'll be
  honest, I do not use Dired-X very often. If I need to read a file, I'd
  rather use the ~fine-file~ command and navigate my filesystem using
  a path. For all filesystem level operations, I would much rather
  switch to my shell. My Dired-X usage is mostly if I need to open a file
  and I've forgotten the name and need a list of files/directories. And
  even then, it's only if I feel pressed for time, or if a coworker is
  over my shoulder.

  The keybinds are only for vim-like navigation. Nothing special exists
  outside of those.

  I customise how the filesystem is displayed. Dired takes in standard ~ls~
  flags, which is really nice.

  | Switch                    | Description                                         |
  |---------------------------+-----------------------------------------------------|
  | -k                        | Default to 1024-byte blocks for disk usage.         |
  | -a                        | Do not ingore entires starting with ~.~.            |
  | -B                        | Do not list implied entries ending with =~=.        |
  | -h                        | Use human readable file sizes (1G instead of 1024). |
  | -l                        | Use a long listing format.                          |
  | --group-directories-first | Show directories at the top of the listing.         |

  #+BEGIN_SRC emacs-lisp
    (use-package dired
      :ensure nil
      :config
      (setq dired-listing-switches "-kaBhl --group-directories-first")

      ;; Disable nag when jumping to another dired-x buffer
      (put 'dired-find-alternate-file 'disable nil)

      (general-define-key
       :states 'normal
       :keymaps 'dired-mode-map
       "l" 'dired-find-alternate-file
       "h" 'my-dired-up-directory
       "o" 'dired-sort-toggle-or-edit
       "v" 'dired-toggle-marks
       "m" 'dired-mark
       "u" 'dired-unmark
       "U" 'dired-unmark-all-marks
       "c" 'dired-create-directory
       "n" 'evil-search-next
       "N" 'evil-search-previous
       "q" 'kill-this-buffer))
  #+END_SRC

* Magit
	Magit is a Git porcelain for Emacs. Just like with Dired-X, I normally
	default to the shell and use the Git CLI. However, I've heard such
	good things about Magit that I figure I should give it a proper shot.

	#+BEGIN_SRC emacs-lisp
		(use-package magit)
	#+END_SRC

  I am using the black magic [[https://github.com/emacs-evil/evil-magit][~evil-magit~]] package for Magit's keybinds. The
  defaults seem sane enough, so I am going to stick with them until I feel like
  it needs some configuration.

	#+BEGIN_SRC emacs-lisp
		(use-package evil-magit)
	#+END_SRC

** Magit Keybinds
    | Keybind | Command | Description                   |
    |---------+---------+-------------------------------|
    | SPC g s | magit   | Open the Magit status buffer. |

		 #+BEGIN_SRC emacs-lisp
			 (general-define-key
				:states 'normal
				:prefix "SPC g"
				"s" 'magit)
		 #+END_SRC
* Spellchecking
  I use Emacs for writing documents on a regular basis. Usually this means
  an ~org~ or Markdown file, but this could also be LaTeX files. I also
  this also could be comments within source code. Lastly, I like to draft emails
  within Emacs. This means I need spellchecking on the fly within Emacs to keep
  my documents professional. Flyspell is /the/ package for spell checking in
  Emacs. I use the popup menu from ~flyspell-correct~ to go through correction
  options. I also use ~auto-dictionary~ to automatically switch between
  dictionaries. I need this occasionally to go between English and French
  documents.

  #+BEGIN_SRC emacs-lisp
    (use-package flyspell
      :config
      ;; Auto-start flyspell within Markdown, Org-mode, and TeX files
      (add-hook 'markdown-mode-hook 'flyspell-mode)
      (add-hook 'org-mode-hook 'flyspell-mode)
      (add-hook 'latex-mode 'flyspell-mode))

    (use-package flyspell-correct-popup
      :ensure flyspell-correct-popup)

    (use-package auto-dictionary
      :ensure auto-dictionary
      :config
      (add-hook 'flyspell-mode-hook 'auto-dictionary-mode))
  #+END_SRC

** Spellchecking Keybinds
    | Keybind | Command                   | Description                                             |
    |---------+---------------------------+---------------------------------------------------------|
    | SPC s b | flyspell-buffer           | Manually invoke flyspell and check the entire buffer.   |
    | SPC s c | flyspell-correct-at-point | Correct the spelling of the work underneath the cursor. |
    | SPC s n | flyspell-goto-next-error  | Move the cursor to the next Flyspell error.             |

		 #+BEGIN_SRC emacs-lisp
       (general-define-key
        :states 'normal
        :prefix "SPC s"
        "b" 'flyspell-buffer
        "c" 'flyspell-correct-at-point
        "n" 'flyspell-goto-next-error)
		 #+END_SRC

    | Keybind | Command       | Description                            |
    |---------+---------------+----------------------------------------|
    | SPC t s | flyspell-mode | Toggle flyspell in the current buffer. |

		 #+BEGIN_SRC emacs-lisp
       (general-define-key
        :states 'normal
        :prefix "SPC t"
        "s" 'flyspell-mode)
		 #+END_SRC

    | Keybind | Command               | Description                                |
    |---------+-----------------------+--------------------------------------------|
    | j, k    | popup-(next previous) | Go to the next/previous entry in the list. |

		 #+BEGIN_SRC emacs-lisp
       (general-define-key
        :states 'normal
        :keymaps 'popup-keymap
        "j" 'popup-next
        "k" 'popup-previous)
		 #+END_SRC
* Programming
	A little known fact. Occasionally, I use Emacs to program. Outrageous
	I know, but it's true. For any language I use, I try to leverage a
	Language Server if available. Using a lang. server simplifies the setup,
	and allows me to share one server configuration across several editors.
	As long as the functionality is in the server, I can guarantee it will
	be available in every editor I use. If no lang. server is available, or
	if there is some functionality not available in the lang. server, I will
  fall back to some sort of ~lang-mode~ package. Using both is also a valid
	option, as long as they do not conflict or result in displaying some chunks
	of information twice.

	#+BEGIN_SRC emacs-lisp
		(use-package lsp-mode
			:init
			(add-hook 'prog-mode-hook #'lsp))
	#+END_SRC

	Flycheck is used for some linting by ~lsp-mode~.

	#+BEGIN_SRC emacs-lisp
		(use-package flycheck
			;; Flycheck by default
			:init (global-flycheck-mode)
			:config
			;; Disable flycheck on checkdoc
			(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
	#+END_SRC

	Company is the completion framework I leverage with ~lsp-mode~.

	#+BEGIN_SRC emacs-lisp
    (use-package company
      ;; Run company-mode globally for the entire session
      :config
      (add-hook 'after-init-hook #'global-company-mode))

    (use-package company-lsp
      :config
        ;; Add company-lsp as a backend to company-mode
        (push 'company-lsp company-backends)

        ;; Cache completions if the cached results are incomplete
        (setq company-lsp-cache-candidates 'auto)

        ;; Fetch completion results asynchronously. No need to lock up just to
        ;; fetch results from the language server.
        (setq company-lsp-async t)

        ;; Enable snippet expansion from the language sever.
        (setq company-lsp-enable-snippet t)

        ;; Allow recompletion in the case there are other completion trigger
        ;; characters.
        (setq company-lsp-enable-recompletion t))
	#+END_SRC

	~lsp-ui~ gives much higher-level interactions with ~lsp-mode~:

	- Doc :: Fetch documentation and display it in a popup buffer.
	- Flycheck :: LSP interactions via Flycheck, like outputting the full list
							 and navigating between info/warnings/errors.
	- iMenu :: LSP interaction via ~imenu~.
	- Peek :: Enable peeking & jumping to definitions.
	- Sideline :: Display LSP actions and Flycheck output on the right-hand side
							 of the buffer.

	I deliberately disable the Doc functionality, as I find it intrusive. It also
	sometimes renders with an incorrect size. Instead, I have a key binding to
	enable/disable the Doc. The same goes for the ~imenu~ buffer.

	I change the face for the peek references to match the Leuven ~org-block~
	colours.

	The Sideline is a feature that I used to also disable, but after tweaking it
	a bit and removing the symbol information I find it very handy. The few tweaks
	I make are changing the face to match the ~ol1~ face from Leuven theme, and
	adding a prefix to the code actions panel. The only issue I still have with it
	is the Flycheck diagnostic information for /info/ showing up as a hideously
	bright green.

	#+BEGIN_SRC emacs-lisp
		(use-package lsp-ui
			:config
			(setq lsp-ui-sideline-enable t)
			(setq lsp-ui-sideline-ignore-duplicate t)
			(setq lsp-ui-sideline-code-actions-prefix " â„¹ ")
			(set-face-attribute 'lsp-ui-sideline-code-action nil
													:weight 'bold
													:overline "#A7A7A7"
													:foreground "#3C3C3C"
													:background "#F0F0F0")

			(setq lsp-ui-flycheck-enable t)
			(setq lsp-ui-doc-enable nil) ; Disable the Docs by default

			(set-face-attribute 'lsp-ui-peek-peek nil
													:background "#FFFFE0")
			(set-face-attribute 'lsp-ui-peek-list nil
													:background "#FFFFE0")
			(set-face-attribute 'lsp-ui-peek-filename nil
													:foreground "#4183C4"
													:background nil)
			(set-face-attribute 'lsp-ui-peek-highlight nil
													:background "#F6FECD"
													:slant 'italic)
			(set-face-attribute 'lsp-ui-peek-selection nil
													:foreground "#333333"
													:background "#F6FECD")
			(set-face-attribute 'lsp-ui-peek-header nil
													:underline "#A7A6AA"
													:foreground "#555555"
													:background "#E2E1D5")
			(set-face-attribute 'lsp-ui-peek-footer nil
													:underline "#A7A6AA"
													:foreground "#555555"
													:background "#E2E1D5")

			(defun max/toggle-lsp-ui-doc ()
				"Toggle the UI Doc"
				(interactive)
				(if (lsp-ui-doc--visible-p)
						(lsp-ui-doc-hide)
					(lsp-ui-doc-show)))

			(defun max/toggle-lsp-ui-imenu ()
				"Toggle the ~lsp-ui~ ~imenu~ buffer."
				(interactive)
				(if (get-buffer "*lsp-ui-imenu*")
						(kill-buffer "*lsp-ui-imenu*")
					(lsp-ui-imenu))))
	#+END_SRC

** Language Server Protocol Keybindings
    | Keybind   | Command                      | Description                                       |
    |-----------+------------------------------+---------------------------------------------------|
    | SPC e b   | lsp-format-buffer            | Format the entire buffer.                         |
    | SPC e o   | lsp-organize-imports         | If possible, organize all imports in the buffer.  |
    | SPC e r   | lsp-rename                   | Rename the item at point across the project.      |
    | SPC e n   | flycheck-next-error          | Go to the next error.                             |
    | SPC e p   | flycheck-previous-error      | Go to the previous error.                         |
    | SPC e a   | lsp-execute-code-action      | Execute a code action based on the current point. |
    | SPC e l   | lsp-ui-flycheck-list         | Open the flycheck buffer.                         |
    | SPC e f d | lsp-ui-peek-find-definitions | Peek find the definition of the item at point.    |
    | SPC e f r | lsp-ui-peek-find-references  | Peek find all references to the item at point.    |
    | SPC e u   | toggle-lsp-ui-doc            | Show the doc window if the window is not already  |
    |           |                              | visible.                                          |
    | SPC b m   | toggle-lsp-ui-imenu          | Show the imenu buffer if not already visible.     |

	 #+BEGIN_SRC emacs-lisp
		 (general-define-key
			:states 'normal
			:prefix "SPC e"
			"b" 'lsp-format-buffer
			"o" 'lsp-organize-imports
			"r" 'lsp-rename
			"n" 'flycheck-next-error
			"p" 'flycheck-previous-error
			"f d" 'lsp-ui-peek-find-definitions
			"f r" 'lsp-ui-peek-find-references
			"a" 'lsp-execute-code-action
			"l" 'lsp-ui-flycheck-list
			"u" 'max/toggle-lsp-ui-doc)

			(general-define-key
			:states 'normal
			:prefix "SPC b"
			"m" 'max/toggle-lsp-ui-imenu)

			;; Fix 'q' not quiting the Flycheck list buffer
			(general-define-key
			:states 'normal
			:keymap 'lsp-ui-flycheck-list-mode-map
			"q" 'lsp-ui-flycheck-list--quit)
	 #+END_SRC

** Programming & Markup Languages
   The following are specific configurations for individual programming
   and markup languages.

*** Docker
    ~~~
    npm install --global dockerfile-language-server-nodejs
    ~~~

    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :mode (("Dockerfile\\'" . dockerfile-mode)))
    #+END_SRC

*** Emacs Lisp
    #+BEGIN_SRC emacs-lisp
      (use-package elisp-slime-nav
        :config
        (add-hook 'emacs-lisp-mode-hook 'elisp-slime-nav-mode))

      (general-define-key
       :states 'normal
       :prefix "SPC m"
       "e" 'pp-eval-last-sexp)
    #+END_SRC

*** Golang
    ~~~
    go get gopls
    ~~~

    #+BEGIN_SRC emacs-lisp
      (use-package go-mode
        :config
        ;; Run goimports before saving a file
        (setq gofmt-command "goimports")
        (add-hook 'before-save-hook 'gofmt-before-save))
    #+END_SRC

*** Markdown
    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :commands (markdown-mode gfm-mode)
        ;; Use GitHub markdown on README.md files, and regular Markdown on others
        :mode (("README\\.md'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)))
    #+END_SRC

*** Typescript
    #+BEGIN_SRC emacs-lisp
      (use-package typescript-mode)
      (use-package json-mode)
    #+END_SRC

* Org-mode
	Org-mode was the killer feature that got me to try out Emacs to begin with,
	and honestly it's probably the main reason I keep using Emacs.

	I have tried many solutions to low tech or plain text note taking and
	productivity tools, but until org-mode I was constantly disappointed.
	Todo.txt, Markdown, XML with custom schemas, and Bullet Journals.
	Bullet Journals was the closest to a perfect solution, but my natural
  tendency to forget my journal at home lead to me dropping it as well.

	Combining org-mode with Orgzly and Syncthing has become my perfect
	organization, productivity, and note taking stack.

	#+BEGIN_SRC emacs-lisp
		(use-package org
			:ensure org
			:commands (org-mode org-capture org-agenda orgtbl-mode)
			:mode ("\\.org$" . org-mode)
			:config
			;; Linum mode on large (>1000 lines) Org files results in masive
			;; slowdowns when going over a lot of collapsed lines.
			(add-hook 'org-mode-hook (lambda() (linum-relative-mode -1)))

			;; Automatically wrap lines at the 80th column.
			(add-hook 'org-mode-hook (lambda() (set-fill-column 80) (auto-fill-mode))))
	#+END_SRC

** General Settings
	The location of my Org files differs depending on what machine I am on. On my
	personal machine, the directory is ~/home/max/doc/org/~. It is synced to
  Nextcloud as a backup solution, and synced to my mobile phone with Syncthing.
  On my work machine, it is under ~F:\org\~. This drive is a network drive. Not
	really a backup, but better than only keeping it local.

	#+BEGIN_SRC emacs-lisp
		(defvar org-base-dir)

		(if (eq system-type 'gnu/linux)
				;; linux
				(setq org-base-dir "/home/max/doc/org")
			;; windows
			(setq org-base-dir "f:/org"))

		(setq org-directory org-base-dir)
		(setq org-agenda-files (list (concat org-directory "/agenda")))
		(setq org-default-notes-file (concat (car org-agenda-files) "/inbox.org"))
	#+END_SRC

	Automatically add a timestamp once a task is set to done.

	#+BEGIN_SRC emacs-lisp
		(setq org-log-done 'time)
	#+END_SRC

	Enable fast todo selection. By default, the task states have to be cycled
	through. By setting fast todo, I can jump into any state.

	#+BEGIN_SRC emacs-lisp
		(setq org-use-fast-todo-selection t)
	#+END_SRC

*** Org-mode General
    | Keybind | Command         | Description                                     |
    |---------+-----------------+-------------------------------------------------|
    | SPC o a | org-agenda      | Opens the agenda command view. This lets me     |
    |         |                 | interactively decide how I want to use the      |
    |         |                 | org-mode agenda.                                |
    | SPC o c | org-capture     | Opens the capture view with an interactive list |
    |         |                 | of available org-capture templates.             |
    | SPC o o | org-agenda-list | Opens the agenda list view. Shows me my agenda  |
    |         |                 | For today and the next two days                 |
    | SPC o s | org-search-view | Opens the search view for org-mode. Lets me     |
    |         |                 | construct a complex search query.               |
    | SPC o t | org-tags-view   | Opens a view to filter org-mode items by tag.   |
    | SPC o 0 | org-clock-out   | Clocks out of the running clock.                |

	 #+BEGIN_SRC emacs-lisp
		 (general-define-key
			:states 'normal
			:prefix "SPC o"
			"a" 'org-agenda
			"c" 'org-capture
			"o" 'org-agenda-list
			"s" 'org-search-view
			"t" 'org-tags-view
			"0" 'org-clock-out)
	 #+END_SRC

	 | Keybind   | Command               | Description                               |
	 |-----------+-----------------------+-------------------------------------------|
	 | SPC m S h | org-demote-subtree    | Demote the entire subtree down one level. |
	 | SPC m S j | org-move-subtree-down | Move the subtree below the subtree        |
	 |           |                       | immediately after it.                     |
	 | SPC m S k | org-move-subtree-up   | Move the subtree above the subtree        |
	 |           |                       | immediately before it.                    |
	 | SPC m S l | org-promote-subtree   | Promote the entire subtree up one level.  |

	 #+BEGIN_SRC emacs-lisp
			(general-define-key
			 :states 'normal
			 :keymaps 'org-mode-map
			 :prefix "SPC m S"
			 "h" 'org-demote-subtree
			 "j" 'org-move-subtree-down
			 "k" 'org-move-subtree-up
			 "l" 'org-promote-subtree)
	 #+END_SRC

	 | Keybind | Command                         | Description                                          |
	 |---------+---------------------------------+------------------------------------------------------|
	 | TAB     | org-cycle                       | Cycle the state of the headline at point (open/close |
	 |         |                                 | headlines).                                          |
	 | $       | org-end-of-line                 | Move cursor to the end of the line.                  |
	 | ^       | org-beginning-of-line           | The opposite of ~$~                                  |
	 | gh      | outline-up-heading              | Move cursor up one heading level.                    |
	 | gj      | org-forward-heading-same-level  | Move cursor down one heading within the same level.  |
	 | gk      | org-backward-heading-same-level | Move cursor up one heading within the same level.    |
	 | gl      | outline-next-visible-heading    | Move cursor down one heading level.                  |
	 | t       | org-todo                        | Change keyword state of heading.                     |
	 | T       | org-insert-todo-heading         | Insert a heading at point with TODO keyword already  |
	 |         |                                 | in place.

	 #+BEGIN_SRC emacs-lisp
		 (general-define-key
			:states 'normal
			:keymaps 'org-mode-map
			"TAB" 'org-cycle
			"$" 'org-end-of-line
			"^" 'org-beginning-of-line
			"gh" 'outline-up-heading
			"gj" 'org-forward-heading-same-level
			"gk" 'org-backward-heading-same-level
			"gl" 'outline-next-visible-heading
			"t" 'org-todo
			"T" 'org-insert-todo-heading)
	 #+END_SRC

	 Evil-org supplements missing keybinds until I get off my ass and define them.

	 #+BEGIN_SRC emacs-lisp
		 (use-package evil-org
			 :ensure t
			 :after org
			 :config
			 (progn
				 (add-hook 'org-mode-hook 'evil-org-mode)
				 (add-hook 'evil-org-mode-hook
									 (lambda ()
										 (evil-org-set-key-theme)))
				 (require 'evil-org-agenda)
				 (evil-org-agenda-set-keys)))
	 #+END_SRC

** Emphasis
	 #+BEGIN_SRC emacs-lisp
		 (defun max/org-bold-region ()
			 (interactive)
			 (org-emphasize ?\*))
		 (defun max/org-code-region ()
			 (interactive)
			 (org-emphasize ?\~))
		 (defun max/org-italic-region ()
			 (interactive)
			 (org-emphasize ?\/))
		 (defun max/org-strike-through-region ()
			 (interactive)
			 (org-emphasize ?\+))
		 (defun max/org-underline-region ()
			 (interactive)
			 (org-emphasize ?\_))
		 (defun max/org-verbatim-region ()
			 (interactive)
			 (org-emphasize ?\=))
	 #+END_SRC

*** Emphasis Keybinds
		| Keybind   | Command                       | Description                       |
		|-----------+-------------------------------+-----------------------------------|
		| SPC m x b | max/org-bold-region           | Surround entire region with ~*~.  |
		| SPC m x c | max/org-code-region           | Surround entire region with ~\~~. |
		| SPC m x i | max/org-italic-region         | Surround entire region with ~/~.  |
		| SPC m x s | max/org-strike-through-region | Surround entire region with ~+~.  |
		| SPC m x u | max/org-underline-region      | Surround entire region with ~_~.  |
		| SPC m x v | max/org-verbatim-region       | Surround entire region with ~=~.  |

		#+BEGIN_SRC emacs-lisp
			(general-define-key
			 :states 'visual
			 :keymaps 'org-mode-map
			 :prefix "SPC m x"
			 "b" 'max/org-bold-region
			 "c" 'max/org-code-region
			 "i" 'max/org-italic-region
			 "s" 'max/org-strike-through-region
			 "u" 'max/org-underline-region
			 "v" 'max/org-verbatim-region)
		#+END_SRC

** Keywords
	 I keep three sequences for todo keywords. The task sequence, the blocked
	 sequence, and the financial sequence. The task sequence is for tasks
	 that are ongoing and not impeded. The blocked sequence are for tasks that I
	 cannot actively work on. The financial sequence is for not forgetting to
	 pay my phone bill again.

	 The ~RAW~ state is for tasks that have been captured, but haven't yet been
	 fleshed out. Maybe the task is just an idea, or it needs more information
	 before it's actionable.

	 The ~WAITING~, ~HOLD~, ~CANCELLED~, and ~OVERDUE~ state leave a timestamp
	 and a require a comment whenever it is switched too. I use to document why
	 a task has reached this (usually negative) state.

	 #+BEGIN_SRC emacs-lisp
		 (setq org-todo-keywords
					 '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)")
						 (sequence "RAW(-)" "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")
						 (sequence "EXPENSE(e)" "OVERDUE(o@/!)" "|" "PAID(p)")))
	 #+END_SRC

** Tags
	 I use tags to help prioritise my work. I use the Eisenhower matrix to
	 prioritise my work. Each task is prioritised as either important or not
	 important, and urgent or not urgent. Priority is assigned then from where
	 on the matrix the task falls:

	 1. Important & Urgent (Do ASAP)
	 2. Important & Not Urgent (Schedule)
	 3. Not Important & Urgent (Delegate if possible)
	 4. Not Important & Not Urgent (Do it later)

	 I use the ~PROJECT~ tag to indicate that all sub-headers are part of the same
	 overarching task defined in the tagged header. I make sure to exclude this
	 tag from the inheritance list so all sub-headers do not get the ~PROJECT~
	 tag.

	 #+BEGIN_SRC emacs-lisp
		 (setq org-use-tag-inheritance t)
		 (setq org-tags-exclude-from-inheritance '("PROJECT"))
		 (setq org-tag-alist '(("important" . ?i)
													 ("urgent" . ?u)
													 ("!important" . ?I)
													 ("!urgent" . ?U)
													 ("PROJECT" . ?P)))
	 #+END_SRC

** Capture
	 Org-capture is a fantastic feature I wish I used more often. Most of the time
	 when capturing would be useful I'm away from my laptop. I use Orgzly's quick
	 note feature to accomplish a similar result, but the options for /how/ to
	 capture the information is far more limited than org-capture proper.

	 That being said, setting up capture templates for my work machine would
	 probably be a blessing. I'm on that thing 7.5 hours a day.

	 All templates are defined externally in ~*.txt~ files to keep this
	 configuration file clean. The goal of each template is to capture the minimum
	 amount of information required for the item to be actionable (excluding the
	 ~RAW~ capture). These are my templates:

	 - Task :: An actionable todo item with a proper name, estimate, some sort of
						date, context tag, and priority tags. They are placed into the
						general task bucket in my main org file
	 - Raw task :: An idea, task, or note that requires refinement. Could be a
								passing idea, a reminder, a quote, etc. Raw tasks are to never
								leave the my inbox.
	 - Note :: A name, timestamp, content. Just a note.

	#+BEGIN_SRC emacs-lisp
		(setq org-capture-templates
					'(("t" "Task" entry (file "~/doc/org/agenda/inbox.org")
						 (file "~/.emacs.d/capture-templates/task.txt"))
						("T" "Raw task" entry (file "~/doc/org/agenda/inbox.org")
						 (file "~/.emacs.d/capture-templates/raw-task.txt"))
						("n" "Note" entry (file "~/doc/org/agenda/inbox.org")
						 (file "~/.emacs.d/capture-templates/note.txt"))))
	#+END_SRC

*** Capture/Source Keybinds
    | Keybind | Command              | Description                       |
    |---------+----------------------+-----------------------------------|
    | SPC m ' | org-edit-src-exit    | Save and exit the org edit buffer |
    | SPC m k | org-edit-src-abort   | Abandon the changes in the buffer |
    | SPC m " | org-capture-finalize | Save and file the capture buffer  |
    | SPC m a | org-capture-kill     | Abandon the capture buffer        |

		#+BEGIN_SRC emacs-lisp
			(general-define-key
			 :states 'visual
			 :keymaps '(org-capture-mode-map org-src-mode-map)
			 :prefix "SPC m"
			 "'" 'org-edit-src-exit
			 "k" 'org-edit-src-abort
			 "\"" 'org-capture-finalize
			 "a" 'org-capture-kill)
		#+END_SRC

** Refile
	 Pick refile targets using paths. This works nicely with how I name "bucket"
	 headlines for storing like tasks/notes.

	 #+BEGIN_SRC emacs-lisp
		 (setq org-refile-use-outline-path t)
	 #+END_SRC

	 The refile targets generated are based off of my agenda files, and only
	 goes down three levels.

	 #+BEGIN_SRC emacs-lisp
		 (setq org-refile-targets '((org-agenda-files . (:maxlevel . 3))))
	 #+END_SRC

** Agenda
	 By default, show today and the next two days when opening the agenda.
	 When planning ahead, three days is usually good enough to see if I'm
	 overworking myself.

	 #+BEGIN_SRC emacs-lisp
		 (setq org-agenda-span 3)
	 #+END_SRC

	 Pushes off the tags if I'm viewing the agenda in a verticle split on the
	 laptop. I'd rather see the content of the heading rather than the tags
	 associated in most contexts.

	 #+BEGIN_SRC emacs-lisp
		 (setq org-agenda-tags-column -100)
	 #+END_SRC

	 Do not show scheduled/deadlined tasks if the task is in a done state.
	 Prevents cluttering with completed tasks,

	 #+BEGIN_SRC emacs-lisp
		 (setq org-agenda-skip-scheduled-if-done t)
		 (setq org-agenda-skip-deadline-if-done t)
	 #+END_SRC

	 Do show the post-scheduled counter if the deadline counter is current
	 visible in the agenda.

	 #+BEGIN_SRC emacs-lisp
		 (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
	 #+END_SRC

** Headlines
	#+BEGIN_SRC emacs-lisp
		;; Requires org-fonitfy-done-headline to be non-nil
		(setq org-fontify-done-headline t)
	#+END_SRC

	Org-bullets changes out the asterisks for UTF-8 symbols.

	#+BEGIN_SRC emacs-lisp
		(use-package org-bullets
			:ensure org-bullets
			:config
			(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
  #+END_SRC

*** Headline Keybinds
		| Keybind   | Command                            | Description                                     |
		|-----------+------------------------------------+-------------------------------------------------|
		| spc m a   | org-archive-subtree                | takes the current subtree and moves it to an    |
		|           |                                    | archive files. I do this periodically to hide   |
		|           |                                    | done state entries without deleting them.       |
		| SPC m b   | org-tree-to-indirect-buffer        | Opens the current subtree into a buffer where   |
		|           |                                    | it is the sole subtree. This lets me edit the   |
		|           |                                    | tree without visible distractions of the        |
		|           |                                    | surrounding trees. As well, it removes the      |
		|           |                                    | chance of accidental manipulating an unrelated  |
		|           |                                    | tree.                                           |
		| SPC m c   | org-toggle-checkbox                | Toggles a checkbox between checked and empty.   |
		| SPC m d   | org-deadline                       | Adds a deadline to the entry.                   |
		| SPC m D   | org-insert-drawer                  | Inserts a drawer at the cursor with a prompted  |
		|           |                                    | name. Drawers are good for hiding information.  |
		| SPC m e   | org-export-dispatch                | Opens the interactive export buffer. This is    |
		|           |                                    | used by me to export org files to PDF when      |
		|           |                                    | sharing my notes.                               |
		| SPC m E   | org-set-effort                     | Creates an /effort/ property in the properties  |
		|           |                                    | drawer. I set effort in the estimated amount    |
		|           |                                    | of time it will take to do a task.              |
		| SPC m i   | org-clock-in                       | Begin tracking the amount of time spent on a    |
		|           |                                    | task.                                           |
		| SPC m n   | org-narrow-to-subtree              | Like ~SPC m b~, but doesn't open a new buffer   |
		|           |                                    | that isolates the subtree.                      |
		| SPC m N   | widen                              | Undo ~SPC m n~.                                 |
		| SPC m o   | org-open-at-point                  | Opens whatever the pointer is on. Used mainly   |
		|           |                                    | for opening links.                              |
		| SPC m O   | org-clock-out                      | Stop tracking time against a specific task.     |
		| SPC m p   | org-set-property                   | Create a property with a given name and value.  |
		| SPC m Q   | org-clock-cancel                   | Stop the current clock and undo all time        |
		|           |                                    | tracked.                                        |
		| SPC m r   | org-refile                         | Refile an entry.                                |
		| SPC m s   | org-scheduled                      | Sets the scheduled property of an entry.        |
		| SPC m t   | org-show-todo-tree                 | Show a tree of all todo's in the open buffer.   |
		| SPC m y   | org-todo-yesterday                 | Change the status of a headline, but apply it   |
		|           |                                    | as if it happened yesterday. Good if I forgot   |
		|           |                                    | to complete a habit style task.                 |
		| SPC m !   | org-time-stamp-inactive            | Creates an inactive timestamp.                  |
		| SPC m ^   | org-sort                           | Sorts the entire active tree.                   |
		| SPC m *   | org-toggle-heading                 | Toggled the data under the pointer into an org  |
		|           |                                    | heading.                                        |
		| SPC m RET | org-insert-heading-respect-content | Inserts a heading after the current subtree.    |
		| SPC m :   | org-set-tags                       | Set the tags on a heading at the current point. |
		| SPC m '   | org-edit-special                   | Used mostly when editing source code blocks     |
		|           |                                    | inside an org file.                             |
		| SPC m /   | org-sparse-tree                    | Create a sparse tree based on some filter       |
		|           |                                    | criteria.                                       |
		| SPC m .   | org-time-stamp                     | Create a time stamp.                            |

	 #+BEGIN_SRC emacs-lisp
		 (general-define-key
			:states 'normal
			:keymaps 'org-mode-map
			:prefix "SPC m"
			"a" 'org-archive-subtree
			"b" 'org-tree-to-indirect-buffer
			"c" 'org-toggle-checkbox
			"d" 'org-deadline
			"D" 'org-insert-drawer
			"e" 'org-export-dispatch
			"E" 'org-set-effort
			"i" 'org-clock-in
			"n" 'org-narrow-to-subtree
			"N" 'widen
			"o" 'org-open-at-point
			"O" 'org-clock-out
			"p" 'org-set-property
			"Q" 'org-clock-cancel
			"r" 'org-refile
			"s" 'org-schedule
			"t" 'org-show-todo-tree
			"y" 'org-todo-yesterday
			"!" 'org-time-stamp-inactive
			"^" 'org-sort
			"*" 'org-toggle-heading
			"RET" 'org-insert-heading-respect-content
			":" 'org-set-tags
			"'" 'org-edit-special
			"/" 'org-sparse-tree
			"." 'org-time-stamp)
	 #+END_SRC

	 | Keybind   | Command                          | Description                                       |
	 |-----------+----------------------------------+---------------------------------------------------|
	 | SPC m h i | org-insert-heading-after-current | Exactly what it sounds like.                      |
	 | SPC m h I | org-insert-heading               | Insert heading at current point.                  |
	 | SPC m h s | org-insert-subheading            | Creates a new heading one level below the current |
	 |           |                                  | heading.                                          |
	 | SPC m h l | org-insert-link                  | Insert a org-mode link at point.                 |

	 #+BEGIN_SRC emacs-lisp
			(general-define-key
			 :states 'normal
			 :keymaps 'org-mode-map
			 :prefix "SPC m h"
			 "i" 'org-insert-heading-after-current
			 "I" 'org-insert-heading
			 "s" 'org-insert-subheading
			 "l" 'org-insert-link)
	 #+END_SRC


#  LocalWords:  iBuffer Dired Magit ELPA MELPA Keybinds Keybind SPC
#  LocalWords:  emacs modeline
