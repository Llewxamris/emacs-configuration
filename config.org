;;; -*- lexical-binding: t; -*-
#+TITLE: Maxwell Haley's Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#  LocalWords:  Leuven Flycheck modeline keybinds Cliplink ido minibuffer GC ui
#  LocalWords:  iBuffer Dired Magit ELPA MELPA Keybinds Keybind SPC SCP UTF CLI
#  LocalWords:  emacs modeline paren pinky dired magit Magit's LaTeX Flyspell
#  LocalWords:  flyspell lang lsp flycheck imenu ibuffer Avy linter Yasnippet
#  LocalWords:  backend Writegood actioned actioning

* Forward
My living monolith of a Emacs configuration file. Bred through trial, error, and
peeking at the configurations of people far more wise than I. Here's a list of
some of those configurations I've lifted. Can't let me get away red handed.

- [[https://github.com/angrybacon/dotemacs][angrybacon/dotemacs]]
- [[https://github.com/valignatev/dotfiles][valignatev/dotfiles]]
- [[https://github.com/sachac/.emacs.d][sachac/.emacs.d]]
- [[https://github.com/wasamasa/dotemacs][wasamasa/dotemacs]]

The entire configuration file is written out in Emacs Org Mode. The goal is to
describe and justify my decisions in a way that both:

1. Anyone interested in building their own configuration can browse through my
own and make informed decisions on what they want to co-opt
2. I can figure out /"What the f--- was I thinking."/ in the next few months

I also tried to use some humour to make reading through this YAML file on
steroids enjoyable. I apologize in advance.

To start of this configuration, lets define my name and email address before
kicking off the package initialization.

  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Maxwell R. Haley")
    (setq user-mail-address "maxwell.r.haley@gmail.com")
  #+END_SRC

* Preparation & Package Management
** Remote Package Archives
Define what remote archives to use as package repositories. GNU ELPA is the
default package repository for Emacs. It is a solid repository, but limited in
content. MELPA has a much larger selection of modern and up-to-date packages.

Org is the Org mode repository.

#+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-archives '(("melpa" . "https://melpa.milkbox.net/packages/")
                              ("org" . "https://orgmode.org/elpa/")
                              ("gnu" . "https://elpa.gnu.org/packages/")))

     (unless (bound-and-true-p package--initialized)
       (setq package-enable-at-startup nil)
       (package-initialize))

     (eval-and-compile
       (setq use-package-verbose (not (bound-and-true-p byte-compile-current-file))))
#+END_SRC

** Use Package
Check the packages directory for manually installed packages.

#+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (defvar package-dir (expand-file-name "packages" user-emacs-directory)
         "The packages directory")
       (add-to-list 'load-path package-dir))
#+END_SRC

/Ensure/ ~use-package~ is always installed alongside this configuration. I
/ensure/ to always /ensure/ my packages are available, and then /ensure/ I have
the newest packages available.

Any built-in Emacs packages, or packages that are actually apart of a separate
package, are not ensured by adding ~:ensure nil~ to their declaration.

Also included is ~auto-package-update~. It automatically updates packages three
days after the previous upgrade was ran.

#+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-and-compile
       (setq use-package-always-ensure t))

     (eval-when-compile
       (require 'use-package))

     (put 'use-package 'lisp-indent-function 1)

     (use-package auto-package-update
       :custom
       (auto-package-update-interval 3)
       (auto-package-update-delete-old-versions t)
       (auto-package-update-hide-results t)
       :config
       (auto-package-update-maybe))
#+END_SRC

** Custom
Hide away the ~custom~ configurations by dumping it into the void. I try to
avoid using ~custom~ in general. I find figuring out how to do it manually much
more +infuriating+ entertaining.

#+BEGIN_SRC emacs-lisp
     (use-package cus-edit
       :ensure nil
       :custom
       (custom-file null-device))
#+END_SRC

** General
I prefer defining keys using the [[https://github.com/noctuid/general.el][General]] syntactic sugar style. It interops
extremely well with Evil, and makes it absurdly easy to use mnemonic style
motions.

#+BEGIN_SRC emacs-lisp
      (use-package general)
#+END_SRC

** Automatically Byte Compile Emacs Lisp Libraries
Byte compiling Emacs Lisp files allows them to load and execute faster. I've
never tested the speed difference of compiled vs. not-compiled, but I assume the
performance increase over time is negated by the amount of time spent setting up
my Emacs configuration.

#+BEGIN_SRC emacs-lisp
      (use-package auto-compile
        :config
          ;; Auto-compile on both loading and saving.
          (auto-compile-on-load-mode)
          (auto-compile-on-save-mode))
#+END_SRC

** Reload & Edit Configuration
The following function definition allows me to reload my Emacs configuration on
the fly.

| Keybind   | Command                        | Description                        |
|-----------+--------------------------------+------------------------------------|
| SPC f e E | max/open-emacs-configuration   | Open the config file for Emacs     |
| SPC f e R | max/reload-emacs-configuration | Reload my Emacs configuration file |

#+BEGIN_SRC emacs-lisp
     (defun max/reload-emacs-configuration ()
       (interactive)
       (load-file (concat user-emacs-directory "init.el")))

     (defun max/open-emacs-configuration ()
       "Open ~config.org~, my literate Emacs configuration file.
     If the file is already open in another buffer, switch to that buffer."
       (interactive)
       (find-file (concat user-emacs-directory "config.org")))

     (general-define-key
      :states 'normal
      :prefix "SPC f e"
      "E" 'max/open-emacs-configuration
      "R" 'max/reload-emacs-configuration)
#+END_SRC

* Emacs General
** Essentials
Emacs comes with a large set of defaults designed to make adoption simple for
new users. Once you get a hang of Emacs, some of these defaults can feel like
they get in the way or are unnecessary. There are also some settings that are
not set by default to avoid confusing new users. And like the set defaults, some
of them may be very useful once you are more familiar with Emacs.

| Keybind   | Command                   | Description                                     |
|-----------+---------------------------+-------------------------------------------------|
| SPC w d   | delete-window             | Delete (close) the currently focused window.    |
| SPC w s h | split-window-vertically   | Split the window, resulting in two vertically  |
|           |                           | side-by-side windows.                           |
| SPC w s v | split-window-horizontally | Split the window, resulting in two horizontally |
|           |                           | side-by-side windows.                           |

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    ;; Force syntax highlighting for all supported major modes.
    (global-font-lock-mode t)

    ;; Change the "Yes or No" prompt to just be "y or n".
    (defalias 'yes-or-no-p 'y-or-n-p)

    ;; Disable font compacting on GC when on Windows. Trades off removing
    ;; some lag for increased memory usage.
    (when (eq system-type 'windows-nt)
      (setq inhibit-compacting-font-caches t))

    ;; Set the font. According to HLISSNER (of Doom Emacs fame), adding
    ;; the font to the default frame list results in better start times.
    ;; I agree, and have also noticed that on Windows, I have to reload
    ;; the config for the font to actually apply.
    (if (eq system-type 'gnu/linux)
        (add-to-list 'default-frame-alist '(font . "Iosevka Term SS04-12"))
                     (add-to-list 'default-frame-alist '(font . "Iosevka Term-12")))

    :custom
    ;; Disable the startup screen & message.
    (inhibit-startup-screen t )

    ;; Disable the bell that makes me feel shame every time it lets me
    ;; know I fumbled a keystroke. Worse, its almost like hearing the
    ;; bell guarantees the next few strokes will also be fumbled
    ;; resulting in more bells. Disable this existential horror please.
    (ring-bell-function 'ignore) ;*ding-ding* SHAME. *ding-ding* SHAME.

    ;;	Show keystrokes after 0.1 seconds. Any longer and the panic sets in.
    (echo-keystrokes 0.01)

    ;; Do not show a dialog box when mouse commands result in a question
    ;; being asked. I actively avoid using the mouse, and accidently
    ;; triggering a popup is very frustrating.
    (use-dialog-box t)

    ;; Use spaces instead of tabs. And when tabs are seen, limit them to two
    ;; characters.
    (indent-tabs-mode nil)
    (tab-width 2)

    ;; Use UTF-8 encoding, because this is ${CURRENT_YEAR}.
    (locale-coding-system 'utf-8)

    ;; Always load the newest version of a file.
    (load-prefer-newer t)

    :general
    ;; Window manipulation keybindings
    (:states 'normal
     :prefix "SPC w"
     ""    '(:ignore t :which-key "window manipulation prefix")
     "["   'evil-window-decrease-height
     "]"   'evil-window-increase-height
     "{"   'evil-window-decrease-width
     "}"   'evil-window-increase-width
     "="   'balance-windows
     "c"   'delete-other-windows
     "d"   'delete-window
     "f"   'make-frame
     "H"   'evil-window-move-far-left
     "i"   '(:ignore t :which-key "")
     "J"   'evil-window-move-very-bottom
     "K"   'evil-window-move-very-top
     "L"   'evil-window-move-far-right
     "s"   '(:ignore t :which-key "window splitting prefix")
     "s h" 'split-window-vertically
     "s v" 'split-window-horizontally)

    ;; Global state/buffer state keybindings
    (:states 'normal
     :prefix "SPC e"
     ""  '(nil :which-key "global state manipulation prefix")
     "N" 'widen))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package simple
    :ensure nil
    :config
    ;; Show column numbers on the modeline.
    (column-number-mode)

    ;; Show the size of the current buffer in the modeline.
    (size-indication-mode)

    ;; Visually wrap lines when the characters are too close to the fringe.
    (global-visual-line-mode 1)
    :custom
    ;; If the cursor is on the end of a line, stay on the end of the line when
    ;; moving to the next or previous line.
    (track-eol t)

    ;; Always show the current line number and column number
    ;; in the buffer. When both enabled, they appear like this:
    ;; ~~~
    ;; (line, col)
    ;; ~~~
    (line-number-mode t)
    (column-number-mode t)

    ;; Adds some curly arrows to help show which lines are being effected by
    ;; visual line wrapping.
    (visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))

    :general
    ;; Line modification and jump keybind
    (:states 'normal
     :prefix "SPC"
     "j n" 'split-line)

    ;; Text manipulation/analysis keybindings
    (:states '(visual normal)
     :prefix "SPC x"
     ""    '(:ignore t :which-key "text manipulation/analysis prefix")
     "c"   'count-words-region
     "d"   '(:ignore t :which-key "text deletion prefix")
     "d w" 'delete-trailing-whitespace
     "u"   'downcase-region
     "U"   'upcase-region)

    ;; Text insertion keybindings
    (:states 'normal
     :prefix "SPC i"
     ""  '(:ignore t :which-key "text inserttion keybindings")
     "u" 'insert-char))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package align
    :ensure nil
    :general
    ;; Text alignment keybind
    (:states 'visual
     "SPC x a" 'align-regexp))
#+END_SRC

Similarly, I like having which-key around to pat me on the back and tell me I'm
doing okay when I start a motion and forget where to go next.

#+BEGIN_SRC emacs-lisp
     (use-package which-key
       :hook (after-init . which-key-mode))
#+END_SRC

Automatically decompress archives when reading, and then compress again when
writing.

#+BEGIN_SRC emacs-lisp
     (auto-compression-mode t)
#+END_SRC

Enable the Garbage Collector Magic Hack. This will kick in the built in GC
whenever the system is idle,

#+BEGIN_SRC emacs-lisp
     (use-package gcmh
       :ensure t
       :init
       (gcmh-mode 1))
#+END_SRC

[[https://github.com/purcell/exec-path-from-shell][Exec-path-from-shell]] ensures my shell's environment variables are all available
within Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (eq system-type 'gnu/linux)
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

** Help!
Describing things is one of the best ways to understand how Emacs works.
Whenever I need to trouble shoot, the first thing I do is describe whatever it
is I'm having problems with.

| Keybind   | Command           | Description                                |
|-----------+-------------------+--------------------------------------------|
| SPC h d f | describe-function | Look up the definition of a function.      |
| SPC h d k | describe-key      | Look up the function invoked by the        |
|           |                   |  given key.                               |
| SPC h d m | describe-mode     | Displays the documentation for the current |
|           |                   | major and minor modes.                     |
| SPC h d s | describe-symbol   | Look up the definition of a symbol.        |
| SPC h d v | describe-variable | Look up the definition and value of a      |
|           |                   | variable.                                  |

#+BEGIN_SRC emacs-lisp
  (use-package help-fns
    :ensure nil
    :general

    ;; Help & documentation keybindings
     (:states 'normal
     :prefix "SPC h"
     ""    '(nil :which-key "help prefix")
     "d"   '(nil :which-key "describe thing prefix")
     "d f" 'describe-function
     "d F" 'describe-face
     "d k" 'describe-key
     "d m" 'describe-mode
     "d s" 'describe-symbol
     "d v" 'describe-variable
     "m"   'man
     "i"   'info)

    ;; Help mode navigation keybindings
    (:states 'normal
     :keymap 'help-map
     :prefix "g"
     ""  '(:ignore t :which-key "go in help doc prefix")
     "b" 'help-go-back
     "f" 'help-go-forward))
#+END_SRC

** Files
Of course, the core purpose of a file editor is to edit files. And when we have
edited a file, that file needs to be saved. Emacs has plenty of built in saving
functionality, as well as the ability to make plenty of backups in case you
forgot to save.

| Keybind | Command                    | Description                                   |
|---------+----------------------------+-----------------------------------------------|
| SPC q q | save-buffers-kill-terminal | Prompt to save all buffers, then close Emacs. |
| SPC f r | save-buffer                | Save the currently focused buffer.            |
| SPC f w | find-file                  | Navigate to a file via a tab-complete         |
|         |                            | path editor.                                  |

#+BEGIN_SRC emacs-lisp
  (use-package files
    :ensure nil
    :hook
    ;; Always delete trailing whitespace when saving a file.
    (before-save . delete-trailing-whitespace)

    ;; Automatically save buffers when losing focus, or when a frame is deleted.
    (focus-out-hook . save-some-buffers)
    (delete-frame-functions . save-some-buffers)

    :custom
    ;; Emacs auto-backups files, which is great. But, it dumps them in the current
    ;; directory, which is terrible. Instead, dump them into ~.emacs.d/~.
    (backup-directory-alist '(("." . "~/.emacs.d/backups")))

    ;; I don't want to have my hard drive littered with backups, so I set Emacs to
    ;; only keep up to three backup versions. I also don't want to have a nag every
    ;; time it wants to delete a backup. I also include version controlled files,
    ;; just in case.
    (version-control t)
    (kept-old-versions 2)
    (delete-old-versions t)
    (vc-make-backup-files t)

    ;; Always include a trailing newline at the end of a file.
    (require-final-newline t)
    (delete-trailing-lines nil)

    :general
    ;; Quit Emacs keybindings
    (:states 'normal
     :prefix "SPC q"
     ""  '(:ignore t :which-key "quiting emacs prefix")
     "q" 'save-buffers-kill-terminal
     "Q" '(server-mode :which-key "kill emacs server")
     "r" '(server-start :which-key "restart emacs server"))

    ;; File manipulation keybindings
    (:states 'normal
     :prefix "SPC f"
     ""  '(:ignore t :which-key "file manipulation prefix")
     "c" 'copy-file
     "D" 'delete-file
     "w" 'save-buffer
     "r" 'find-file
     "R" 'rename-file))

#+END_SRC

It is also very useful to automatically refresh buffers. That is: If the content
of a buffer changes (such as a file changing on disk), then redraw the buffer. I
also set it to refresh non-file buffers (such as Dired buffers), and to suppress
the nag.

#+BEGIN_SRC emacs-lisp
     (use-package autorevert
       :ensure nil
       :config
       (global-auto-revert-mode t)
       :custom
       (global-auto-revert-non-file-buffers t)
       (auto-revert-verbose nil))
#+END_SRC

I also want to backup all of the commands I've used, so I can re-invoke them in
later sessions. Command history is essential for any command based environment.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :ensure nil
    :config
    (savehist-mode)
    :custom
    ;; Save all minibuffer histories
    (savehist-save-minibuffer-history t)
    ;; Set the file location for storing minibuffer history
    (savehist-file "~/.emacs.d/savehist")
    ;; Include the kill-ring, search-ring, and regexp-search-ring to the
    ;; history file.
    (savehist-additional-variables '(kill-ring
                                     search-ring
                                     regexp-search-ring)))
#+END_SRC

Tramp let's me use Emacs to edit remote files. For example, changing a Docker
compose file from the comfort of my local machine. I default to editing over SSH
instead of using SCP. [[https://www.emacswiki.org/emacs/TrampMode#toc12][I also need to override the shell prompt pattern to
prevent Tramp from hanging.]]

#+BEGIN_SRC emacs-lisp
     (use-package tramp
       :ensure nil
       :custom
       (tramp-default-method "ssh" "SSH is faster than SCP.")
       (tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*"
                                   "Not having this pattern set causes Tramp to hang on connection."))
#+END_SRC

** Graphical User Interface
Seeing three bars on a slot machine is good. Seeing three bars on Emacs is bad.

#+BEGIN_SRC emacs-lisp
     (use-package menu-bar
       :ensure nil
       :config
       (menu-bar-mode -1))

     (use-package scroll-bar
       :ensure nil
       :config
       (scroll-bar-mode -1))

     (use-package tool-bar
       :ensure nil
       :config
       (tool-bar-mode -1))

     (use-package tooltip
       :ensure nil
       :defer t
       :custom
       (tooltip-mode -1))
#+END_SRC

Undo/Redo window layouts using C-c <left> and C-c <right>. Lets me fix
accidental destruction the layout of windows and buffers.

#+BEGIN_SRC emacs-lisp
     (use-package winner
       :ensure nil
       :config
       (winner-mode 1))
#+END_SRC

** Editor
*** Character Encoding & General Formatting
Use UTF-8 encoding everywhere. I rarely run Emacs in a terminal, and even then
my terminal of choice also supports UTF-8. No reason to not enable.

#+BEGIN_SRC emacs-lisp
  (use-package mule
    :ensure nil
    :config
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)

    :custom
    (sentence-end-double-space nil))
#+END_SRC

To congratulate myself for taking a stand against non-UTF-8 encoding, I will
reward myself with some pretty symbols.

#+BEGIN_SRC emacs-lisp
      (use-package pretty-mode
        :config
        (global-pretty-mode t))
#+END_SRC

On top of ~pretty-mode~, I also use ~prettify-symbols-mode~ to replace some Org
Mode text.

#+BEGIN_SRC emacs-lisp
  (use-package prog-mode
    :ensure nil
    :custom
    (prettify-symbols-alist '(("#+BEGIN_SRC" . "⚞")
                              ("#+END_SRC" . "⚟"))))
#+END_SRC

*** Colour Theme
I've recently switched over to the [[https://github.com/fniessen/emacs-leuven-theme][Leuven]] theme. I've started switching over to
light-themes for my systems in general. I keep my brightness relatively low, so
dark-themes end up having poor contrast. Leuven was built with Org-mode in mind,
and gives Org files a more cohesive feeling.

#+BEGIN_SRC emacs-lisp
      (use-package leuven-theme
        :config
        ;; Load the theme unless running without an interactive terminal.
        (unless noninteractive
          (load-theme 'leuven t)))
#+END_SRC

*** Highlighting & Pair Matching
Highlight the row the cursor is currently on.

#+BEGIN_SRC emacs-lisp
      (use-package hl-line
        :config
        (global-hl-line-mode))
#+END_SRC

When the cursor is over a parenthesis, highlight all of the content between that
parenthesis and it's matching opening/closing parenthesis. This is mostly useful
when working with Lisp, but I have found it helpful in other situations as well.
So I set it globally.

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :config
    (show-paren-mode)

    (defun max/toggle-show-paren-style ()
      "Toggle between the \"expression\" and \"parenthesis\" `show-paren-mode' style."
      (interactive)
      (cond ((eq show-paren-style 'expression)
             (setq show-paren-style 'parenthesis))
            ((eq show-paren-style 'parenthesis)
             (setq show-paren-style 'expression))))
    :custom
    ;; By default, highlight the entire expression between the two parens.
    (show-paren-style 'expression)
    ;; No delay between putting the cursor on a paren, and highlighting.
    (show-paren-delay 0)
    :general
    (:states 'normal
             :prefix "SPC t"
             "p" 'max/toggle-show-paren-style))
#+END_SRC

Automatically insert a closing symbol if an opening symbol is entered (paren.,
bracket, brace, etc.). The closing symbol is after the point of the cursor, so I
can keep typing without having to adjust to the newly entered text.

#+BEGIN_SRC emacs-lisp
      (use-package elec-pair
        :config
        (electric-pair-mode))
#+END_SRC

*** Doom Modeline
A """minimalist""" modeline. It's minimalist, so that justifies satisfying my
need for fancy colours and icons everywhere I look so I can keep my ADD rattled
brain distracted while the rest of me tries to do real work.

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :custom
    ;; Forcefully enable icons in the modeline. This is necessary when running
    ;; Emacs as a daemon.
    (doom-modeline-icon t))

  (use-package all-the-icons)
#+END_SRC

*** Relative Line Numbering
Vim's /relative line numbers/ was an invaluable feature that made using Vim's
input style simple. It makes taking advantage of multi-line motions or edits
very simple for someone like me who is terrible at on the fly mental math.

I previously used the [[https://github.com/coldnew/linum-relative][linum-relative]] package for relative line numbering. Now, I
use the ~display-line-numbers~ package that comes with Emacs 26+. Linum had
major performance problems when working on large files, including this one. I
actually disabled ~linum-mode~ in all Org files because it became such a
problem. These performance issues went away after switching to
~display-line-numbers~.

#+BEGIN_SRC emacs-lisp
      (use-package display-line-numbers
        :ensure nil
        :config
        (global-display-line-numbers-mode)
        :custom
        (display-line-numbers-type 'relative))
#+END_SRC

*** Smooth Scrolling
Leaves just a bit of room at the bottom and top of the window when scrolling.
Something about it just feels so right. Uses the [[https://github.com/aspiers/smooth-scrolling][smooth-scrolling package]].

#+BEGIN_SRC emacs-lisp
      (use-package smooth-scrolling
        :config
        (smooth-scrolling-mode 1))
#+END_SRC

*** Expand Region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :general
    (:states '(normal visual)
     :prefix "SPC v"
     "" 'er/expand-region))
#+END_SRC

* Evil Mode
Vim has the superior input style. There. I said it. Modal-based bindings flow so
much better for me, both in thinking and in executing. Using Emacs native
modifier bindings feels incredibly restrictive in comparison. My left hand needs
to positioned to always be able to hold down Control, Alt, or Meta. Making my
pinky the main work-horse of my typing, to me, feels like a terrible mistake. On
the other hand, modal style editing lets me use my fingers equally. Even when I
need to use some sort of modifier key (mostly the space bar), it ends up being
my thumb doing the work. My thumb can withstand the brute force of slamming it
down in frustration during a heated moment. My pinky is barely even an
appendage.

Evil mode gives me Vim-like keybindings without having to invest in any sort of
remapping. I, of course, still add my own mappings and re-mappings. Not because
Vim lacks anything, but entirely due to personal preference. Without Evil, I
don't think I could see myself ever using Emacs seriously.

| Keybind   | Command                   | Description                                     |
|-----------+---------------------------+-------------------------------------------------|
| SPC w h   | evil-window-left          | Focus the window to the left.                   |
| SPC w j   | evil-window-bottom        | Focus the window below.                         |
| SPC w k   | evil-window-up            | Focus the window above.                         |
| SPC w l   | evil-window-right         | Focus the window to the right.                  |

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (evil-set-initial-state 'ibuffer-mode 'normal)
    (evil-set-initial-state 'magit-mode 'normal)
    (evil-mode 1)
    :custom
    ;; Do not load evil-keybindings.el. Evil Collection handles setting
    ;; these bindings where necessary.
    (evil-want-keybinding nil))

  (use-package evil-commands
    :ensure nil
    :general
    (:states 'normal
     :prefix "SPC w"
     "h" 'evil-window-left
     "j" 'evil-window-down
     "k" 'evil-window-up
     "l" 'evil-window-right))

  (use-package evil-commentary
    :ensure t
    :config
      ;; Enable by default
      (evil-commentary-mode))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init)
    :custom
    ;; If ~use-tng~ is not set to null, then ~company-lsp~ does not
    ;; autocomplete correctly.
    (evil-collection-company-use-tng nil))
#+END_SRC

* Completion
** Company
[[http://company-mode.github.io/][Company]] is a framework for text insertion completion. For example, automatically
completing function invocations while typing them out. Or suggesting words while
editing prose.

 #+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (global-company-mode)
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))
#+END_SRC

** Yasnippet
[[http://joaotavora.github.io/yasnippet/][Yasnippet]] is a template system that enables expanding keywords into text or code
snippets. For example, entering ~emacs-lisp_~ and hitting ~<tab>~ expands into a
full ~BLOCK_SRC~ element with the language set to ~emacs-lisp~.

 #+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode))

  (use-package yasnippet-snippets
    :after yasnippet)
#+END_SRC

* Avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :general
    ;; Jump based navigation keybindings
    (:keymaps 'normal
     :prefix "SPC j"
     "" '(:ignore t :which-key "jump prefix")
     "j" 'avy-goto-char
     "l" 'avy-goto-line
     "w" 'avy-goto-word-0))
#+END_SRC

* Ace
#+BEGIN_SRC emacs-lisp
  (use-package ace-link
    :config
    (general-define-key
     :keymaps 'help-map
     "o" 'ace-link-help))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :config
    (ace-window-display-mode)

    (general-define-key
     :states 'normal
     "SPC w W" 'ace-window))
#+END_SRC

* ido
[[https://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] (Interactively Do Things) is a built-in minor mode that provides
"interactive" text entry. This mostly means the minibuffer will filter away all
entries that could not match your input without having to hit ~TAB~ each time.

#+BEGIN_SRC emacs-lisp
  (use-package ido
    :ensure nil
    :config
    (ido-mode)
    (ido-everywhere)

    :custom
    (ido-enable-flex-matching t "If no prefix matches are found, look for the \
                                  sequence of characters anywhere in an entry.")

    :general
    ;; Buffer manipulation keybindings
    (:states 'normal
     :prefix "SPC b"
     "" '(:ignore t :which-key "buffer manipulation prefix")
     "b" 'ido-switch-buffer
     "d" 'ido-kill-buffer
     "D" 'kill-this-buffer
     "m" 'kill-some-buffers
     "R" 'revert-buffer))
#+END_SRC

I do not like the default in-line display used by ido. [[https://github.com/creichert/ido-vertical-mode.el][Ido-vertical-mode]] reads
better to me, displaying all entries in a single column.

I would prefer something grid-like, such as [[https://github.com/larkery/ido-grid-mode.el][ido-grid-mode]], but I have found it
slows down Emacs too much.

#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
     :after ido
     :config
     (ido-vertical-mode)
     :custom
     (ido-vertical-define-keys 'C-n-and-C-p-only "Use C-n/C-p to move selection."))
#+END_SRC

Ido-everywhere unfortunately does not apply everywhere. To get Ido completion
nearly everywhere, I use the [[https://github.com/DarwinAwardWinner/ido-completing-read-plus][ido-completing-read+]] package. Assisting is the
[[https://github.com/DarwinAwardWinner/crm-custom][crm-custom]] package that allows Ido completion in functions that can take in
multiple inputs.

To supplement anything else that doesn't get Ido completion, I enable the
built-in ~icomplete~ mode.

#+BEGIN_SRC emacs-lisp
    (use-package ido-completing-read+
      :ensure t
      :after ido
      :config
      (ido-ubiquitous-mode))

    (use-package crm-custom
      :ensure t
      :after ido-completing-read+
      :config
      (crm-custom-mode))

    (use-package icomplete
      :after ido-completing-read+
      :config
      (icomplete-mode))
#+END_SRC

* iBuffer
iBuffer is a great tool for managing the many buffers created in day-to-day
Emacs use.

| Keybind | Command | Description               |
|---------+---------+---------------------------|
| SPC b b | ibuffer | Open the iBuffer...buffer |

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :ensure nil
    :general
    ;; iBuffer opening keybind
    (:states 'normal
     :prefix "SPC b"
     "B" 'ibuffer))
#+END_SRC

* Dired-X
Dired-X is the extended version of the Emacs file manager Dired. I'll be honest,
I do not use Dired-X very often. If I need to read a file, I'd rather use the
~fine-file~ command and navigate my file system using a path. For all file
system level operations, I would much rather switch to my shell. My Dired-X
usage is mostly if I need to open a file and I've forgotten the name and need a
list of files/directories. And even then, it's only if I feel pressed for time,
or if a coworker is over my shoulder.

The keybinds are only for vim-like navigation. Nothing special exists outside of
those.

I customise how the file system is displayed. Dired takes in standard ~ls~
flags, which is really nice.

| Switch                    | Description                                         |
|---------------------------+-----------------------------------------------------|
| -k                        | Default to 1024-byte blocks for disk usage.         |
| -a                        | Do not ignore entries starting with ~.~.            |
| -B                        | Do not list implied entries ending with =~=.        |
| -h                        | Use human readable file sizes (1G instead of 1024). |
| -l                        | Use a long listing format.                          |
| --group-directories-first | Show directories at the top of the listing.         |

| Keybind | Command    | Description                                     |
|---------+------------+-------------------------------------------------|
| SPC b d | dired      | Prompt for a path, and open Dired at that path. |
| SPC b D | dired-jump | Opens Dired in the directory of the currently   |
|         |            | focused buffer.                                 |

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :custom
    ;; ~ls~ switches passed to Dired.
    (dired-listing-switches "-kaBhl --group-directories-first")

    ;; Recursively delete and copy directories.
    (dired-recursive-deletes t)
    (dired-recursive-copies t)
    :config
    ;; Reuse Dired buffers when navigating.
    (put 'dired-find-alternate-file 'disabled nil)

    :general
    ;; Dired buffer opening keybindings
    (:states 'normal
     :prefix "SPC b"
     "d" 'dired
     "D" 'dired-jump)

    ;; Jump to dired keybindings
    (:states 'normal
     :prefix "SPC j"
     "d" 'dired-jump
     "D" 'dired-jump-other-window))

  (use-package all-the-icons-dired
    :requires all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

* Magit
Magit is a Git porcelain for Emacs. Just like with Dired-X, I normally default
to the shell and use the Git CLI. However, I've heard such good things about
Magit that I figure I should give it a proper shot.

| Keybind | Command | Description                   |
|---------+---------+-------------------------------|
| SPC g s | magit   | Open the Magit status buffer. |

#+BEGIN_SRC emacs-lisp
  (use-package magit
    ;; Don't load Magit on my work (Windows) machine.
    :if (eq system-type 'gnu/linux)
    :custom
    (magit-completing-read-function 'magit-ido-completing-read "Use Ido completion.")

    :general
    ;; Magit keybind
    (:states 'normal
     :prefix "SPC g"
     ""  '(:ignore t :which-key "magit prefix")
     "s" 'magit))
#+END_SRC

I am using the black magic [[https://github.com/emacs-evil/evil-magit][~evil-magit~]] package for Magit's keybinds. The
defaults seem sane enough, so I am going to stick with them until I feel like it
needs some configuration.

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :after (magit evil)
    :custom
    ;; Default to the Normal state in Magit
    (evil-magit-state 'normal))
#+END_SRC

* Spellchecking
I use Emacs for writing documents on a regular basis. Usually this means an
~org~ or Markdown file, but this could also be LaTeX files. I also this also
could be comments within source code. Lastly, I like to draft emails within
Emacs. This means I need spellchecking on the fly within Emacs to keep my
documents professional. Flyspell is /the/ package for spell checking in Emacs. I
use the popup menu from ~flyspell-correct~ to go through correction options. I
also use ~auto-dictionary~ to automatically switch between dictionaries. I need
this occasionally to go between English and French documents.

| Keybind | Command                   | Description                                             |
|---------+---------------------------+---------------------------------------------------------|
| SPC s b | flyspell-buffer           | Manually invoke flyspell and check the entire buffer.   |
| SPC s c | flyspell-correct-at-point | Correct the spelling of the work underneath the cursor. |
| SPC s n | flyspell-goto-next-error  | Move the cursor to the next Flyspell error.             |
| SPC t s | flyspell-mode             | Toggle flyspell in the current buffer.                  |

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :hook
    ;; Auto-start flyspell within Markdown, Org-mode, TeX, and Git Commit modes
    ((markdown-mode org-mode latex-mode git-commit-mode) . flyspell-mode)

    :general
    (:states 'normal
     :prefix "SPC s"
     ""  '(:ignore t :which-key "flyspell prefix")
     "b" 'flyspell-buffer
     "c" 'flyspell-correct-at-point
     "n" 'flyspell-goto-next-error
     "s" 'flyspell-mode))

  (use-package flyspell-correct-popup)

  (use-package auto-dictionary
    :hook (flyspell-mode . auto-dictionary-mode))
#+END_SRC

* Programming
A little known fact. Occasionally, I use Emacs to program. Outrageous I know,
but it's true.

** Language Server
For any language I use, I try to leverage a Language Server if available. Using
a lang server simplifies the setup, and allows me to share one server
configuration across several editors. As long as the functionality is in the
server, I can guarantee it will be available in every editor I use. If no lang.
server is available, or if there is some functionality not available in the
lang. server, I will fall back to some sort of ~lang-mode~ package. Using both
is also a valid option, as long as they do not conflict or result in displaying
some chunks of information twice.

| Keybind | Command                 | Description                                       |
|---------+-------------------------+---------------------------------------------------|
| SPC e b | lsp-format-buffer       | Format the entire buffer.                         |
| SPC e o | lsp-organize-imports    | If possible, organize all imports in the buffer.  |
| SPC e r | lsp-rename              | Rename the item at point across the project.      |
| SPC e a | lsp-execute-code-action | Execute a code action based on the current point. |

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :hook ((prog-mode go-mode) . lsp)
    :commands lsp
    :custom
    (read-process-output-max (* 1024 1024))
    (lsp-idle-delay 0.500)
    :general
    ;; LSP keybindings
    (:states '(normal visual)
     :prefix "SPC l"
     "" '(:ignore t :which-key "lsp prefix")
     "a" 'lsp-execute-code-action
     "f" 'lsp-format-buffer
     "o" 'lsp-organize-imports
     "r" 'lsp-rename
     "R" 'lsp-restart-workspace))
#+END_SRC

*** LSP Company Backend
Lsp-mode has its own backend for Company, allowing the Company completion
framework to pull suggestions from the running language server.

#+BEGIN_SRC emacs-lisp
  (use-package company-lsp
    :after (lsp company)
    :config
    ;; Add company-lsp as a backend to company-mode
    (push 'company-lsp company-backends)
    :custom
    ;; Cache completions if the cached results are incomplete
    (company-lsp-cache-candidates 'auto)

    ;; Fetch completion results asynchronously. No need to lock up just to
    ;; fetch results from the language server.
    (company-lsp-async t)

    ;; Enable snippet expansion from the language sever.
    (company-lsp-enable-snippet nil)

    ;; Allow recompletion in the case there are other completion trigger
    ;; characters.
    (company-lsp-enable-recompletion t))
#+END_SRC

*** LSP UI
~lsp-ui~ gives much higher-level interactions with ~lsp-mode~:

- Doc :: Fetch documentation and display it in a popup buffer.
- Flycheck :: LSP interactions via Flycheck, like outputting the full list and
              navigating between info/warnings/errors.
- iMenu :: LSP interaction via ~imenu~.
- Peek :: Enable peeking & jumping to definitions.
- Sideline :: Display LSP actions and Flycheck output on the right-hand side of
              the buffer.

I deliberately disable the Doc functionality, as I find it intrusive. It also
sometimes renders with an incorrect size. Instead, I have a key binding to
enable/disable the Doc. The same goes for the ~imenu~ buffer.

I change the face for the peek references to match the Leuven ~org-block~
colours.

The Sideline is a feature that I used to also disable, but after tweaking it a
bit and removing the symbol information I find it very handy. The few tweaks I
make are changing the face to match the ~ol1~ face from Leuven theme, and adding
a prefix to the code actions panel. The only issue I still have with it is the
Flycheck diagnostic information for /info/ showing up as a hideously bright
green.

| Keybind   | Command                      | Description                                      |
|-----------+------------------------------+--------------------------------------------------|
| SPC e l   | lsp-ui-flycheck-list         | Open the flycheck buffer.                        |
| SPC e f d | lsp-ui-peek-find-definitions | Peek find the definition of the item at point.   |
| SPC e f r | lsp-ui-peek-find-references  | Peek find all references to the item at point.   |
| SPC e u   | toggle-lsp-ui-doc            | Show the doc window if the window is not already |
|           |                              | visible.                                         |
| SPC b m   | toggle-lsp-ui-imenu          | Show the imenu buffer if not already visible.    |

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :after lsp
    :hook (lsp . lsp-ui-mode)
    :config
    (defun max/toggle-lsp-ui-doc ()
      "Toggle the UI Doc"
      (interactive)
      (if (lsp-ui-doc--visible-p)
          (lsp-ui-doc-hide)
        (lsp-ui-doc-show)))

    (defun max/toggle-lsp-ui-imenu ()
      "Toggle the ~lsp-ui~ ~imenu~ buffer."
      (interactive)
      (if (get-buffer "*lsp-ui-imenu*")
          (kill-buffer "*lsp-ui-imenu*")
        (lsp-ui-imenu)))

    :custom
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-ignore-duplicate t)
    (lsp-ui-flycheck-enable t)
    (lsp-ui-doc-enable nil) ; Disable the Docs by default

    :custom-face
    (lsp-ui-sideline-code-action ((t (
                                      :foreground "#3C3C3C"
                                      :background "#F0F0F0"))))

    (lsp-ui-peek-peek ((t (:background "#FFFFE0"))))
    (lsp-ui-peek-list ((t (:background "#FFFFE0"))))
    (lsp-ui-peek-filename ((t (
                               :foreground "#4183C4"
                               :background nil))))
    (lsp-ui-peek-highlight ((t (
                                :background "#F6FECD"
                                :slant italic))))
    (lsp-ui-peek-selection ((t (
                                :foreground "#333333"
                                :background "#F6FECD"))))
    (lsp-ui-peek-header ((t (
                             :underline "#A7A6AA"
                             :foreground "#555555"
                             :background "#E2E1D5"))))
    (lsp-ui-peek-footer ((t (
                             :underline "#A7A6AA"
                             :foreground "#555555"
                             :background "#E2E1D5"))))
    :general
    (:states 'normal
     :prefix "SPC l"
     "d"   'lsp-ui-doc-glance
     "e"   'lsp-ui-flycheck-list
     "i"   'lsp-ui-imenu
     "p"   '(:ignore t :which-key "peek prefix")
     "p d" 'lsp-ui-peek-find-definitions
     "p r" 'lsp-ui-peek-find-references))
#+END_SRC

** Flycheck
[[https://www.flycheck.org/en/latest/][Flycheck]] is a fantastic syntax checker and linter for Emacs. It has support for
most major programming languages (mostly) out-of-the-box, and ~lsp-mode~ has
built in support for Flycheck.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :custom
    ;; Disable flycheck on checkdoc
    (flycheck-disabled-checkers '(emacs-lisp-checkdoc))

    :general
    (:states 'normal
     :prefix "SPC e"
     "c" 'flycheck-clear-errors
     "h" 'flycheck-describe-checker
     "l" 'flycheck-list-errors
     "n" 'flycheck-next-error
     "p" 'flycheck-previous-error))
#+END_SRC

** Compilation Buffer
The compilation buffer is a dumb terminal, which means it does not attempt to
escape ANSI codes. This result is cluttering the buffer with the ANSI colour
codes. Emacs can handle these colour codes, but it requires applying a function
against the entire buffers output.

#+BEGIN_SRC emacs-lisp
  (use-package ansi-color
    :ensure nil
    :config
    (defun max/colorize-compilation-buffer ()
      (read-only-mode)
      (ansi-color-apply-on-region compilation-filter-start (point)))

    (add-hook 'compilation-filter-hook 'max/colorize-compilation-buffer))
#+END_SRC

** Programming & Markup Languages
The following are specific configurations for individual programming and markup
languages.

*** Docker
~~~
npm install --global dockerfile-language-server-nodejs
~~~

#+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :mode (("Dockerfile\\'" . dockerfile-mode)))
#+END_SRC

*** Emacs Lisp
Elisp makes the (Emacs) world go round. Making your Elisp editing experience as
comfortable as possible is a must. Being able to whip around functions and
evaluate arbitrary code is a fabulous (and dangerous) power to wield.

#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :commands emacs-lisp-mode
    :general
    ;; Elisp eval & jump keybindings
    (:states 'normal
     :keymaps 'emacs-lisp-mode-map
     :prefix "SPC m"
     "e" '(:ignore t :which-key "elisp eval prefix")
     "e b" 'eval-buffer
     "e e" 'eval-last-sexp
     "e f" 'eval-defun
     "e r" 'eval-region
     "j" '(:ignore t :which-key "elisp jump prefix")
     "j f" 'find-function
     "j F" 'find-function-other-window
     "j v" 'find-variable
     "j V" 'find-variable-other-window))
#+END_SRC

IELM is an inferior Emacs Lisp mode that acts as a REPL for Elisp. REPL-driven
development for Lisp dialects is incredibly popular, and I want to hang with the
cool kids.

#+BEGIN_SRC emacs-lisp
  (use-package ielm
    :ensure nil
    :hook (ielm-mode . turn-on-eldoc-mode)
    :general
    (:states 'normal
     :keymaps 'emacs-lisp-mode-map
     :prefix "SPC m"
     "i" 'ielm))
#+END_SRC

[[https://github.com/abo-abo/lispy][Lispy]] is a fantastic library that makes editing Elisp code so easy, even I can
do it. It provides interactions that are /"safe"/. That is to say, do not result
in non-executable Elisp. For example: deleting a line without dropping a
trailing parenthesis so the code is still valid. Another interaction includes
barfage and slurpage.

[[https://github.com/noctuid/lispyville][Lispyville]] wraps the Lispy interactions in Evil-friendly keybinds. It also
allows for some safe Evil operations. For example: using commentary to comment
out an entire line that ends in a paren will move the paren down a line to avoid
making the Elisp invalid.

#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :hook (emacs-lisp-mode . lispy-mode))

  (use-package lispyville
    :hook (lispy-mode . lispyville-mode)
    :after lispy
    :config
    (lispyville-set-key-theme  '(operators
                                 c-w
                                 prettify
                                 atom-movement
                                 additional-movement
                                 commentary
                                 slurp/barf-lispy
                                 additional
                                 escape))
    :general
    ;; Lispyville keybindings
    (:states 'normal
     :keymaps 'lispyville-mode-map
     :prefix "SPC m"
     "a"   '(:ignore t :which-key "elisp insert at prefix")
     "a i" 'lispyville-insert-at-beginning-of-list
     "a a" 'lispyville-insert-at-end-of-list
     ;; lispyville-beginning-of[-next]-defun binds do not work
     "h"   'lispyville-beginning-of-defun
     "H"   'lispyville-beginning-of-next-defun
     "l"   'lispyville-end-of-defun
     "o"   'lispyville-open-below-list
     "O"   'lispyville-open-above-list
     "w"   '(:ignore t :which-key "elisp wrap prefix")
     "w (" 'lispyville-wrap-round
     "w [" 'lispyville-wrap-brackets
     "w {" 'lispyville-wrap-braces))

#+END_SRC

Edebug is a source-level debugger for Elisp, same as you would find in any
fancy, 21st century IDE. But instead of needing a headless Eclipse instance, you
just need Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package edebug
    :ensure nil
    :commands edebug-defun
    :custom
    ;; Automatically to evaluate instrumentation required for Edebug.
    (edebug-all-defs t)
    ;; Display a trace of function calls in an external buffer.
    (edebug-trace t)
    :general
    (:states 'normal
     :keymaps 'emacs-lisp-mode-map
     :prefix "SPC m"
     "d" 'edebug-defun))
#+END_SRC

*** Golang
~~~
go get gopls
~~~

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :config
    (add-hook 'before-save-hook #'lsp-format-buffer nil t)
    (add-hook 'before-save-hook #'lsp-organize-imports nil t)
    :custom
    ;; Run goimports before saving a file
    (gofmt-command "goimports"))
#+END_SRC

*** Java
#+BEGIN_SRC emacs-lisp
  (use-package java-mode
    :ensure nil
    :commands java-mode)

  (use-package lsp-java
    :ensure t
    :after (java-mode lsp))
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :commands (markdown-mode gfm-mode)
        ;; Use GitHub markdown on README.md files, and regular Markdown on others
        :mode (("README\\.md'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)))
#+END_SRC

*** Typescript
#+BEGIN_SRC emacs-lisp
      (use-package typescript-mode)
      (use-package json-mode)
#+END_SRC

* Org-mode
Org-mode was the killer feature that got me to try out Emacs to begin with, and
honestly it's probably the main reason I keep using Emacs.

I have tried many solutions to low tech or plain text note taking and
productivity tools, but until org-mode I was constantly disappointed. Todo.txt,
Markdown, XML with custom schemas, and Bullet Journals. Bullet Journals was the
closest to a perfect solution, but my natural tendency to forget my journal at
home lead to me dropping it as well.

Combining org-mode with Orgzly and Syncthing has become my perfect organization,
productivity, and note taking stack.

The location of my Org files differs depending on what machine I am on. On my
personal machine, the directory is ~/home/max/doc/org/~. It is synced to
Nextcloud as a backup solution, and synced to my mobile phone with Syncthing. On
my work machine, it is under ~C:\Users\maxwell.haley\Org~. This drive is backed
up on some schedule, but it is not the most robust backup solution. So, I have a
Batch script that copies the contents of my Org directory to my works network
drive. Again this is not truly a backup solution, but the network drive is
replicated on a much more regular basis. I have Task Scheduler run this script
when I log into my machine, every time I lock my machine, and every night at
17:00.

#+BEGIN_SRC bat
    @echo off
    cd /D F:\Org
    xcopy C:\Users\maxwell.haley\Org\*.* /E /Q /Y
#+END_SRC

I treat all "to-do" items in Org Mode as tasks. A task is a to-do item that is,
in theory, ready for action. It must have a clear name, a description (if
required), an estimate, one or many context tags (as well as any other
appropriate tags), and a priority.

Estimates use the format ~HH:MM~, and represent how long I believe the task will
take. Anything greater than one day should instead be a project, and broken down
into smaller tasks. Context tags define where I will be able to action the task.
For example: ~@home~ means this task requires me to be at home in order to
complete it, ~@work~ means I must be at work, and ~@home:@work~ means I can be
either at home or at work. Priorities define how important it is I get to this
task. I follow a system that follows [[https://www.eisenhower.me/eisenhower-matrix/][the Eisenhower Matrix]]. They range from
priority /A/, to priority /D/.

- A :: Task completion is important and urgent. Action as soon as possible
- B :: Task completion is important, but not urgent. Plan when to action
- C :: Task is not important, but is urgent. Delegate if possible
- D :: Task is not important, and not urgent. File appropriately

Priority /D/ can mean either /"Someone has asked me to do something, but did not
give me a deadline or priority. So I am logging the request, but will not action
it until further discussions,"/ or /"This is a personal project/assignment and I
can chose to do it at my leisure"/. In any case, it should be clear which of the
two is applicable.

I keep three states for task to-do keywords:

1. Actionable
2. Blocked
3. Raw

The actionable is for tasks that are either ready for me to action, or are
currently actioned. The keywords are:

- TODO :: A task that is ready for action.

- IN-PROGRESS :: A task that I am actively working on.

- DONE :: A task that I have completed.

The blocked state are for tasks that I cannot actively begin to action or
continue actioning. The keywords are:

- WAITING :: I am waiting for another person to do something before I can
             continue this task (e.g., waiting on an email response, waiting for
             them to complete a task, waiting for more information, etc.)

- HOLD :: The task is now "on hold". Someone (myself included) has decided that
          while this task should get done, it needs to wait until some time in
          the future. Either new priorities have come up, the project has
          stalled, etc.

- DELEGATED :: I have delegated this task to another person, but I still need to
               oversee that it gets done.

- CANCELLED :: This task is no longer of any concern to me.

The last state has only one keyword: ~RAW~. A raw task mean it has not been
properly groomed. The task is just an idea that I must flesh out before I should
think about actioning it. Most newly captured tasks should be raw. Raw tasks
should never leave my Inbox file.

Another type of Org entry is a financial entry. These act as reminders to pay
one-time and re-occurring bills. Financial entries must have a deadline. I have
three states for these entries:

- EXPENSE :: This is an expense that I have yet to pay off.

- OVERDUE :: This is an expense that is past it's deadline, and I should be
             freaking out about it.

- PAID :: I have paid off this expense, and can sleep happy.

I use the ~PROJECT~ tag to indicate that all sub-headers are part of the same
overarching task defined in the tagged header. I make sure to exclude this tag
from the inheritance list so all sub-headers do not get the ~PROJECT~ tag.

| Keybind   | Command                            | Description                                          |
|-----------+------------------------------------+------------------------------------------------------|
| SPC m S h | org-demote-subtree                 | Demote the entire subtree down one level.            |
| SPC m S j | org-move-subtree-down              | Move the subtree below the subtree                   |
|           |                                    | immediately after it.                                |
| SPC m S k | org-move-subtree-up                | Move the subtree above the subtree                   |
|           |                                    | immediately before it.                               |
| SPC m S l | org-promote-subtree                | Promote the entire subtree up one level.             |
| TAB       | org-cycle                          | Cycle the state of the headline at point (open/close |
|           |                                    | headlines).                                          |
| $         | org-end-of-line                    | Move cursor to the end of the line.                  |
| ^         | org-beginning-of-line              | The opposite of ~$~                                  |
| gh        | outline-up-heading                 | Move cursor up one heading level.                    |
| gj        | org-forward-heading-same-level     | Move cursor down one heading within the same level.  |
| gk        | org-backward-heading-same-level    | Move cursor up one heading within the same level.    |
| gl        | outline-next-visible-heading       | Move cursor down one heading level.                  |
| t         | org-todo                           | Change keyword state of heading.                     |
| T         | org-insert-todo-heading            | Insert a heading at point with TODO keyword already  |
|           |                                    | in place.                                            |
| SPC m x b | max/org-bold-region                | Surround entire region with ~*~.                     |
| SPC m x c | max/org-code-region                | Surround entire region with ~\~~.                    |
| SPC m x i | max/org-italic-region              | Surround entire region with ~/~.                     |
| SPC m x s | max/org-strike-through-region      | Surround entire region with ~+~.                     |
| SPC m x u | max/org-underline-region           | Surround entire region with ~_~.                     |
| SPC m x v | max/org-verbatim-region            | Surround entire region with ~=~.                     |
| SPC m h i | org-insert-heading-after-current   | Exactly what it sounds like.                         |
| SPC m h I | org-insert-heading                 | Insert heading at current point.                     |
| SPC m h s | org-insert-subheading              | Creates a new heading one level below the current    |
|           |                                    | heading.                                             |
| SPC m h l | org-insert-link                    | Insert a org-mode link at point.                     |
| SPC m b   | org-tree-to-indirect-buffer        | Opens the current subtree into a buffer where        |
|           |                                    | it is the sole subtree. This lets me edit the        |
|           |                                    | tree without visible distractions of the             |
|           |                                    | surrounding trees. As well, it removes the           |
|           |                                    | chance of accidental manipulating an unrelated       |
|           |                                    | tree.                                                |
| SPC m d   | org-deadline                       | Adds a deadline to the entry.                        |
| SPC m D   | org-insert-drawer                  | Inserts a drawer at the cursor with a prompted       |
|           |                                    | name. Drawers are good for hiding information.       |
| SPC m E   | org-set-effort                     | Creates an /effort/ property in the properties       |
|           |                                    | drawer. I set effort in the estimated amount         |
|           |                                    | of time it will take to do a task.                   |
| SPC m n   | org-narrow-to-subtree              | Like ~SPC m b~, but doesn't open a new buffer        |
|           |                                    | that isolates the subtree.                           |
| SPC m N   | widen                              | Undo ~SPC m n~.                                      |
| SPC m o   | org-open-at-point                  | Opens whatever the pointer is on. Used mainly        |
|           |                                    | for opening links.                                   |
| SPC m p   | org-set-property                   | Create a property with a given name and value.       |
| SPC m r   | org-refile                         | Refile an entry.                                     |
| SPC m s   | org-scheduled                      | Sets the scheduled property of an entry.             |
| SPC m t   | org-show-todo-tree                 | Show a tree of all todo's in the open buffer.        |
| SPC m y   | org-todo-yesterday                 | Change the status of a headline, but apply it        |
|           |                                    | as if it happened yesterday. Good if I forgot        |
|           |                                    | to complete a habit style task.                      |
| SPC m !   | org-time-stamp-inactive            | Creates an inactive timestamp.                       |
| SPC m ^   | org-sort                           | Sorts the entire active tree.                        |
| SPC m *   | org-toggle-heading                 | Toggled the data under the pointer into an org       |
|           |                                    | heading.                                             |
| SPC m RET | org-insert-heading-respect-content | Inserts a heading after the current subtree.         |
| SPC m :   | org-set-tags                       | Set the tags on a heading at the current point.      |
| SPC m '   | org-edit-special                   | Used mostly when editing source code blocks          |
|           |                                    | inside an org file.                                  |
| SPC m /   | org-sparse-tree                    | Create a sparse tree based on some filter            |
|           |                                    | criteria.                                            |
| SPC m .   | org-time-stamp                     | Create a time stamp.                                 |

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure t
       :defines (company-backends)
       :init
       (defun max/org-update-dblocks ()
         "Wrapper around ~org-update-all-dblocks~ that only executes said function if
     the current buffer is an Org buffer. This is intended to be used alongside
     hooks for automatic dynamic block updating."
         (interactive)
         (when (derived-mode-p 'org-mode)
           (org-update-all-dblocks)))

       (defun max/org-add-company-ispell-backend ()
         "Adds the iSpell backend for company locally. To use when writting as appose to programming."
         (make-local-variable 'company-backends)
         (add-to-list 'company-backends 'company-ispell))

       (defun max/org-mode-hook ()
         "Wrapper for all functions that need to be hooked to Org mode."
         (set-fill-column 80)
         (auto-fill-mode)
         (prettify-symbols-mode)
         (max/org-add-company-ispell-backend))

       :commands (org-mode org-capture org-agenda orgtbl-mode)
       :mode ("\\.org$" . org-mode)
       :hook ((before-save . max/org-update-dblocks)
              (org-mode . max/org-mode-hook))
       :config
       ;; I have two machines I use this Emacs configuration on. My personal laptop,
       ;; running Linux, and my work laptop, running Windows. The directories are
       ;; different between them, so I handle setting them here.
       (let* ((max/org-mode-root-directory
               (cond ((eq system-type 'gnu/linux)
                      "/home/max/doc/org")
                     ((or (eq system-type 'windows-nt) (eq system-type 'cygwin))
                      "C:/Users/maxwell.haley/Org")))

              (max/org-agenda-root-directory (concat
                                              max/org-mode-root-directory
                                              "/agenda"))
              (max/org-inbox-file (concat
                                   max/org-agenda-root-directory
                                   "/inbox.org"))
              (max/org-archive-location (concat
                                         max/org-agenda-root-directory
                                         "/archive.org::* Archives")))

         (setq org-directory          max/org-mode-root-directory
               org-agenda-files       (list max/org-agenda-root-directory)
               org-default-notes-file max/org-inbox-file
               org-archive-location   max/org-archive-location))

       (font-lock-add-keywords 'org-mode
                               '(("^ *\\([-]\\) "
                                  (0 (prog1 () (compose-region
                                                (match-beginning 1)
                                                (match-end 1) "•"))))))
       (font-lock-add-keywords 'org-mode
                               '(("^ *\\([+]\\) "
                                  (0 (prog1 () (compose-region
                                                (match-beginning 1)
                                                (match-end 1) "◦"))))))

       ;; Functions to quickly emphasize a region.
       (defun max/org-bold-region ()
         (interactive)
         (org-emphasize ?\*))
       (defun max/org-code-region ()
         (interactive)
         (org-emphasize ?\~))
       (defun max/org-italic-region ()
         (interactive)
         (org-emphasize ?\/))
       (defun max/org-strike-through-region ()
         (interactive)
         (org-emphasize ?\+))
       (defun max/org-underline-region ()
         (interactive)
         (org-emphasize ?\_))
       (defun max/org-verbatim-region ()
         (interactive)
         (org-emphasize ?\=))

       ;;; Keybinds
       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m"
        "b" 'org-tree-to-indirect-buffer
        "d" 'org-deadline
        "D" 'org-insert-drawer
        "E" 'org-set-effort
        "n" 'org-narrow-to-subtree
        "o" 'org-open-at-point
        "p" 'org-set-property
        "r" 'org-refile
        "s" 'org-schedule
        "t" 'org-show-todo-tree
        "y" 'org-todo-yesterday
        "!" 'org-time-stamp-inactive
        "^" 'org-sort
        "*" 'org-toggle-heading
        "RET" 'org-insert-heading-respect-content
        ":" 'org-set-tags
        "'" 'org-edit-special
        "/" 'org-sparse-tree
        "." 'org-time-stamp)

       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m S"
        "h" 'org-demote-subtree
        "j" 'org-move-subtree-down
        "k" 'org-move-subtree-up
        "l" 'org-promote-subtree)

       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        "TAB" 'org-cycle
        "$" 'org-end-of-line
        "^" 'org-beginning-of-line
        "gh" 'outline-up-heading
        "gj" 'org-forward-heading-same-level
        "gk" 'org-backward-heading-same-level
        "gl" 'outline-next-visible-heading
        "t" 'org-todo
        "T" 'org-insert-todo-heading)

       (general-define-key
        :states 'visual
        :keymaps 'org-mode-map
        :prefix "SPC m x"
        "b" 'max/org-bold-region
        "c" 'max/org-code-region
        "i" 'max/org-italic-region
        "s" 'max/org-strike-through-region
        "u" 'max/org-underline-region
        "v" 'max/org-verbatim-region)

       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m h"
        "i" 'org-insert-heading-after-current
        "I" 'org-insert-heading
        "s" 'org-insert-subheading
        "l" 'org-insert-link)

       (add-to-list 'org-modules 'org-habit)

       :custom
       (org-log-done 'time "Inserts a timestamp on task completion.")
       (org-log-into-drawer t)
       (org-use-fast-todo-selection t "Enable jumping to specific states.")
       (org-todo-keywords
        '((sequence "TODO(t)" "IN-PROGRESS(i)" "|" "DONE(d)")
          (sequence "RAW(-)" "WAITING(w@/!)" "HOLD(h@/!)" "DELEGATED(D)" "|" "CANCELLED(c@/!)")
          (sequence "EXPENSE(e)" "OVERDUE(o@/!)" "|" "PAID(p)")))
       (org-use-tag-inheritance t)
       (org-tag-alist '(("@home" . ?h)
                        ("@work" . ?w)
                        ("@daycare" . ?d)
                        ("PROJECT" . ?P)))
       (org-refile-use-outline-path t "
        Pick refile targets using paths. This works nicely with how I name bucket
        headlines for storing like tasks/notes.")
       (org-refile-targets '((org-agenda-files . (:maxlevel . 3))) "
     The refile targets are based off my agenda files, and only goes down three
     levels.")
       (org-fontify-done-headline t)
       (org-startup-indented t "Enable indent mode on all Org files.")
       (org-pretty-entities t "Draw entities as UTF symbols.")
       (org-ellipses " ⤸" "Use fancy symbol to represent headers with additional content."))
   #+END_SRC

   Org-bullets changes out the asterisks for UTF-8 symbols.

   #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :hook (org-mode . org-bullets-mode)
      :custom
      (org-bullets-bullet-list '("✦")))
   #+END_SRC

   Evil-org supplements missing keybinds until I get off my ass and define them.

   #+BEGIN_SRC emacs-lisp
     (use-package evil-org
       :after org
       :config
       (progn
         (add-hook 'org-mode-hook 'evil-org-mode)
         (add-hook 'evil-org-mode-hook
                   (lambda ()
                     (evil-org-set-key-theme)))
         (require 'evil-org-agenda)
         (evil-org-agenda-set-keys)))
   #+END_SRC

** Capture
Org-capture is a fantastic feature I wish I used more often. Most of the time
when capturing would be useful I'm away from my laptop. I use Orgzly's quick
note feature to accomplish a similar result, but the options for /how/ to
capture the information is far more limited than org-capture proper.

That said, setting up capture templates for my work machine would probably be a
blessing. I'm on that thing 7.5 hours a day.

All templates are defined externally in ~*.txt~ files to keep this configuration
file clean. The goal of each template is to capture the minimum amount of
information required for the item to be actionable (excluding the ~RAW~
capture). These are my templates:

- Task :: Capture a ready to action entry. I should be able to fill in all the
          criteria of a task whenever capturing something using this template.
          If anything is unclear, I should be using a raw task.

- Raw task :: A task that requires further fleshing out, or that I require far
              more information on. Raw tasks are not to leave my inbox.

- Note :: A name, timestamp, content. Just a note

- Org Protocol :: Used when capturing a web page via ~org-protocol~. Could
                  become a note, a task, or something else entirely. I invoke
                  Org protocol using the following bookmark:

     #+BEGIN_SRC javascript
   javascript:location.href='org-protocol://capture?template=p&url='+encodeURIComponent(location.href)
       + '&title='+encodeURIComponent(document.title)
       + '&body='+encodeURIComponent(window.getSelection())
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (use-package org-protocol
         :ensure nil
         :after org-capture)
     #+END_SRC

- Journal entry :: An entry into my personal journal. It invokes the function
                   ~max/journal-capture~ to handle creating the correct
                   month/week headers automatically.

| Keybind | Command              | Description                       |
|---------+----------------------+-----------------------------------|
| SPC m " | org-capture-finalize | Save and file the capture buffer  |
| SPC m a | org-capture-kill     | Abandon the capture buffer        |


     #+BEGIN_SRC emacs-lisp
         (use-package org-capture
           :ensure nil
           :config
           (defun max/journal-capture ()
             "Sets the pointer to the correct Month/Week location in my journal file.
       If the week or month does not exist, it is automatically inserted."
             (let ((month (format-time-string "%B"))
                   (week (format-time-string "W%V")))
               (unless (search-forward (format "* %s" month) nil t)
                 (goto-char (point-max))
                 (insert (format "* %s\n** %s\n" month week)))
               (goto-char (point-max))
               (unless (search-backward (format "** %s" week) nil t)
                 (insert (format "** %s\n" week)))
               (goto-char (org-find-olp (list month week) t)) t))

           (defun max/note-capture ()
             "Create a new Org file based on a prompted description. The description is
       used as the title and first-level heading values, and is converted to snake case
       for the file name. Drops the pointer at the end of the new file for Org Capture
       to start off on."
             (let* ((note-desc
                     (read-string "Enter a brief description of the note: "))
                    (note-file-name
                     (replace-regexp-in-string " " "-" (downcase note-desc))))
               (find-file (concat "~/doc/org/" note-file-name ".org"))
               (goto-char (point-min))
               (insert
                (format "#+TITLE: %s\n" note-desc)
                (format "* %s :note:\n" note-desc))
               (goto-char (point-max))))

           :custom
           (org-capture-templates
            '(("t" "Task" entry (file "~/doc/org/agenda/inbox.org")
               (file "~/.emacs.d/capture-templates/task.txt"))
              ("T" "Raw task" entry (file "~/doc/org/agenda/inbox.org")
               (file "~/.emacs.d/capture-templates/raw-task.txt"))
              ("n" "Note" plain (function max/note-capture)
               (file "~/.emacs.d/capture-templates/note.txt"))
              ("j" "Journal Entry" entry (file+function "~/doc/org/journal.org" max/journal-capture)
               (file "~/.emacs.d/capture-templates/journal-entry.txt"))
              ("p" "Org Protocol Capture" entry (file "~/doc/org/agenda/inbox.org")
               (file "~/.emacs.d/capture-templates/protocol.txt"))))

           :general
           ;; Global capture keybind
           (:states 'normal
            :prefix "SPC o"
            "c" 'org-capture))
     #+END_SRC

** Agenda
| Keybind | Command         | Description                                     |
|---------+-----------------+-------------------------------------------------|
| SPC o a | org-agenda      | Opens the agenda command view. This lets me     |
|         |                 | interactively decide how I want to use the      |
|         |                 | org-mode agenda.                                |
| SPC o o | org-agenda-list | Opens the agenda list view. Shows me my agenda  |
|         |                 | For today and the next two days                 |
| SPC o s | org-search-view | Opens the search view for org-mode. Lets me     |
|         |                 | construct a complex search query.               |
| SPC o t | org-tags-view   | Opens a view to filter org-mode items by tag.   |

#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :ensure nil
    :functions (org-end-of-subtree org-entry-get)
    :config
    (general-define-key
     :states 'normal
     :prefix "SPC o"
     "a" 'org-agenda
     "o" 'org-agenda-list
     "s" 'org-search-view
     "t" 'org-tags-view
     "d" 'deft)

    (defun max/org-skip-subtree-if-habit ()
      "Skip an agenda entry if it has a STYLE property equal to \"habit\".

  From https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html"
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (string= (org-entry-get nil "STYLE") "habit")
            subtree-end
          nil)))

    (defun max/org-skip-subtree-if-not-habit ()
      "Skip an agenda entry if it has a STYLE property not equal to \"habit\".

  From https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html"
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (not (string= (org-entry-get nil "STYLE") "habit"))
            subtree-end
          nil)))

    :custom
    (org-agenda-span 3 "
      By default, show today and the next two days when opening the agenda.
      When planning ahead, three days is usually good enough to see if I'm
      overworking myself.")
    (org-agenda-tags-column -100 "
      Pushes off the tags if I'm viewing the agenda in a vertical split on the
      laptop. I'd rather see the content of the heading rather than the tags
      associated in most contexts.")
    (org-agenda-block-separator "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    (org-agenda-custom-commands '(("r" "Raw tasks"
                                   ((todo "RAW"
                                          ((org-agenda-overriding-header
                                            "Unprocessed tasks:")))))
                                  ("d" "Daily agenda"
                                   ((tags "PRIORITY=\"A\""
                                          ((org-agenda-skip-function
                                            '(org-agenda-skip-entry-if
                                              'todo
                                              'done))
                                           (org-agenda-files
                                            '("~/doc/org/agenda/todo.org"))
                                           (org-agenda-overriding-header
                                            "High-priority tasks:")))
                                    (agenda ""
                                            ((org-agenda-span 1)
                                             (org-agenda-skip-function
                                              '(max/org-skip-subtree-if-not-habit))
                                             (org-agenda-overriding-header
                                              "Todays habits:")))
                                    (agenda ""
                                            ((org-agenda-span 1)
                                             (org-agenda-skip-function
                                              '(max/org-skip-subtree-if-habit))
                                             (org-agenda-overriding-header
                                              "Todays tasks:")))
                                    (alltodo ""
                                             ((org-agenda-files
                                               '("~/doc/org/agenda/someday.org"))
                                              (org-agenda-overriding-header
                                               "Other tasks:")))))
                                  ("w" "Weekly agenda"
                                   ((agenda ""
                                            ((org-agenda-span 7)
                                             (org-agenda-overriding-header
                                              "Weekly agenda:")))))
                                  ("p" "Projects"
                                   ((tags "+PROJECT"
                                         ((org-agenda-files
                                           '("~/doc/org/agenda/projects.org"))
                                          (org-tags-match-list-sublevels t)
                                          (org-agenda-overriding-header
                                           "Projects:"))))))))
#+END_SRC

** Clock
| Keybind   | Command                            | Description                                     |
|-----------+------------------------------------+-------------------------------------------------|
| SPC m i   | org-clock-in                       | Begin tracking the amount of time spent on a    |
|           |                                    | task.                                           |
| SPC m O   | org-clock-out                      | Stop tracking time against a specific task.     |
| SPC m Q   | org-clock-cancel                   | Stop the current clock and undo all time        |
|           |                                    | tracked.                                        |
#+BEGIN_SRC emacs-lisp
  (use-package org-clock
    :ensure nil
    :config
    (general-define-key
     :states 'normal
     :keymaps 'org-mode-map
     :prefix "SPC m"
     "i" 'org-clock-in
     "O" 'org-clock-out
     "Q" 'org-clock-cancel))
#+END_SRC

** Archive
| Keybind   | Command                            | Description                                     |
|-----------+------------------------------------+-------------------------------------------------|
| spc m a   | org-archive-subtree                | takes the current subtree and moves it to an    |
|           |                                    | archive files. I do this periodically to hide   |
|           |                                    | done state entries without deleting them.       |

#+BEGIN_SRC emacs-lisp
     (use-package org-archive
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m"
        "a" 'org-archive-subtree))
#+END_SRC

** Lists
| Keybind   | Command                            | Description                                     |
| SPC m c   | org-toggle-checkbox                | Toggles a checkbox between checked and empty.   |

#+BEGIN_SRC emacs-lisp
     (use-package org-list
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m"
        "c" 'org-toggle-checkbox))
#+END_SRC

** Export
| Keybind   | Command                            | Description                                     |
|-----------+------------------------------------+-------------------------------------------------|
| SPC m e   | org-export-dispatch                | Opens the interactive export buffer. This is    |
|           |                                    | used by me to export org files to PDF when      |
|           |                                    | sharing my notes.                               |

#+BEGIN_SRC emacs-lisp
     (use-package ox
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m"
        "e" 'org-export-dispatch))
#+END_SRC

** Source
| Keybind | Command              | Description                       |
|---------+----------------------+-----------------------------------|
| SPC m ' | org-edit-src-exit    | Save and exit the org edit buffer |
| SPC m k | org-edit-src-abort   | Abandon the changes in the buffer |

#+BEGIN_SRC emacs-lisp
      (use-package org-src
        :ensure nil
        :config
        (general-define-key
         :states 'normal
         :keymaps ' org-src-mode-map
         :prefix "SPC m"
         "'" 'org-edit-src-exit
         "k" 'org-edit-src-abort))
#+END_SRC

** Cliplink
[[https://github.com/rexim/org-cliplink][org-cliplink]] grabs a URL from the clipboard, fetches the title of the web page,
then inserts a link element with the URL as the link and the title as the
description. I use this over ~org-protocol~ when I only want to use the web page
as a reference point and not as an entry.

| Keybind   | Command      | Description                       |
|-----------+--------------+-----------------------------------|
| SPC m L h | org-cliplink | Create a link based on the URL in |
|           |              | the clipboard.                    |

#+BEGIN_SRC emacs-lisp
    (use-package org-cliplink
      :ensure t
      :after org
      :config
      (general-define-key
       :states 'normal
       :keymaps 'org-mode-map
       :prefix "SPC m"
       "L" 'org-cliplink))
#+END_SRC

** Deft
Deft is a mode that allows dynamic filtering of plaint-text files. I use it
quickly search through my Org notes. I can enter a fuzzy term like "git" and get
back every file that mentions Git.

#+BEGIN_SRC emacs-lisp
   (use-package deft
     :custom
     (deft-extentions '("org"))
     (deft-directory "~/doc/org/"))
#+END_SRC

** Confluence Markup Export
We use Jira/Confluence at work. I prefer writing up my notes in Org mode, but in
the end they need to be on Confluence. ~ox-jira~ lets me export my Org notes as
Confluence friendly markup. This includes properly generating source blocks,
which is just the best.

#+BEGIN_SRC emacs-lisp
  (use-package ox-jira)
#+END_SRC

** Writegood Mode
I'm not a regular writer, so I often fall into pitfalls. Relying too much on
[[https://en.wikipedia.org/wiki/Weasel_word][weasel words]], or accidentally writing something in the wrong tense.
[[https://github.com/bnbeckwith/writegood-mode][Writegood-mode]] is a fantastic library for someone who is not used to the
challenges of writing. It highlights those weasel words that sneak up on you,
duplicate words, and it highlights phrases that are in the passive voice.

   #+BEGIN_SRC emacs-lisp
     (use-package writegood-mode
       :hook (org-mode markdown-mode latex-mode text-mode)
       :custom-face
       ;; Inherits the ~flyspell-duplicate~ face from Leuven theme
       (writegood-duplicates-face ((t (:inherit flyspell-duplicate))))

       ;; Uses the same colour as the foreground of second level outlines in Org mode
       ;; as defined within Leuven theme.
       (writegood-passive-voice-face ((t (:underline (:style wave :color "#123555")))))

       :general
       ;; Toggle Writegood keybind
       (:states 'normal
        :prefix "SPC t"
        "w" 'writegood-mode))
   #+END_SRC

** Habits
#+BEGIN_SRC emacs-lisp
  (use-package org-habit
    :ensure nil
    :custom
    (org-habit-graph-column 66)
    (org-habit-preceding-days 7))
#+END_SRC

