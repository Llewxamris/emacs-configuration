;;; -*- lexical-binding: t; -*-
#+TITLE: Maxwell Haley's Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#  LocalWords:  Leuven Flycheck modeline keybinds Cliplink ido minibuffer GC ui
#  LocalWords:  iBuffer Dired Magit ELPA MELPA Keybinds Keybind SPC SCP UTF CLI
#  LocalWords:  emacs modeline paren pinky dired magit Magit's LaTeX Flyspell
#  LocalWords:  flyspell lang lsp flycheck imenu ibuffer

* Forward
  My living monolith of a Emacs configuration file. Bred through trial, error, and
  peeking at the configurations of people far more wise than I. Here's a list
	of some of those configurations I've lifted. Can't let me get away red handed.

	- [[https://github.com/angrybacon/dotemacs][angrybacon/dotemacs]]
	- [[https://github.com/valignatev/dotfiles][valignatev/dotfiles]]
	- [[https://github.com/sachac/.emacs.d][sachac/.emacs.d]]
	- [[https://github.com/wasamasa/dotemacs][wasamasa/dotemacs]]

	The entire configuration file is written out in Emacs Org Mode. The goal is to
	describe and justify my decisions in a way that both:

	1. Anyone interested in building their own configuration can browse through my
	own and make informed decisions on what they want to co-opt
	2. I can figure out /"What the f--- was I thinking."/ in the next few months

	I also tried to use some humour to make reading through this YAML file on
	steroids enjoyable. I apologize in advance.

  To start of this configuration, lets define my name and email address before
	kicking off the package initialization.

	#+BEGIN_SRC emacs-lisp
	(setq user-full-name "Maxwell R. Haley")
	(setq user-mail-address "maxwell.r.haley@gmail.com")
	(package-initialize)
	#+END_SRC

* Preparation & Package Management
** Custom
	 Hide away the ~custom~ configurations by dumping it into the void. I try to
   avoid using ~custom~ in general. I find figuring out how to do it manually
   much more +infuriating+ entertaining.

	 #+BEGIN_SRC emacs-lisp
     (use-package cus-edit
       :ensure nil
       :custom
       (custom-file null-device))
	 #+END_SRC

** Remote Package Archives
	 Define what remote archives to use as package repositories. GNU ELPA is the
	 default package repository for Emacs. It is a solid repository, but limited
	 in content. MELPA has a much larger selection of modern and up-to-date packages.

	 Org is the Org mode repository.

	 #+BEGIN_SRC emacs-lisp
     (setq package-archives '(("melpa" . "http://melpa.milkbox.net/packages/")
                              ("org" . "http://orgmode.org/elpa/")
                              ("gnu" . "http://elpa.gnu.org/packages/")))

     (require 'package)
     (unless (bound-and-true-p package--initialized)
       (setq package-enable-at-startup nil)
       (package-initialize))

     (eval-and-compile
       (setq use-package-verbose (not (bound-and-true-p byte-compile-current-file))))
   #+END_SRC

** Use Package
   Check the packages directory for manually installed packages.

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (defvar package-dir (expand-file-name "packages" user-emacs-directory)
         "The packages directory")
       (add-to-list 'load-path package-dir))
   #+END_SRC

	 /Ensure/ ~use-package~ is always installed alongside this configuration. I /ensure/
	 to always /ensure/ my packages are available, and then /ensure/ I have the
	 newest packages available.

   Any built-in Emacs packages, or packages that are actually apart of a
   separate package, are not ensured by adding ~:ensure nil~ to their
   declaration.

	 Also included is ~auto-package-update~. It automatically updates packages three
	 days after the previous upgrade was ran.

	 #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-and-compile
       (setq use-package-always-ensure t))

     (eval-when-compile
       (require 'use-package))

     (put 'use-package 'lisp-indent-function 1)

     (use-package auto-package-update
       :custom
       (auto-package-update-interval 3)
       (auto-package-update-delete-old-versions t)
       (auto-package-update-hide-results t)
       :config
       (auto-package-update-maybe))

	 #+END_SRC

** General
	 I prefer defining keys using the [[https://github.com/noctuid/general.el][General]] syntactic sugar style. It interops
	 extremely well with Evil, and makes it absurdly easy to use mnemonic style
	 motions.

		#+BEGIN_SRC emacs-lisp
      (use-package general)
		#+END_SRC

** Automatically Byte Compile Emacs Lisp Libraries
	 Byte compiling Emacs Lisp files allows them to load and execute faster. I've
	 never tested the speed difference of compiled vs. not-compiled, but I assume
	 the performance increase over time is negated by the amount of time spent
	 setting up my Emacs configuration.

	 #+BEGIN_SRC emacs-lisp
			(use-package auto-compile
				:config
					;; Auto-compile on both loading and saving.
					(auto-compile-on-load-mode)
					(auto-compile-on-save-mode))
	 #+END_SRC

** Reload Configuration
	 The following function definition allows me to reload my Emacs configuration
	 on the fly.

   | Keybind   | Command                        | Description                        |
   |-----------+--------------------------------+------------------------------------|
   | SPC f e R | max/reload-emacs-configuration | Reload my Emacs configuration file |

	 #+BEGIN_SRC emacs-lisp
     (defun max/reload-emacs-configuration ()
       (interactive)
       (load-file (concat user-emacs-directory "init.el")))

     (general-define-key
      :states 'normal
      :prefix "SPC f e"
      "R" 'max/reload-emacs-configuration)
	 #+END_SRC

* Emacs General
** Essentials
	Emacs comes with a large set of defaults designed to make adoption simple for
	new users. Once you get a hang of Emacs, some of these defaults can feel like
	they get in the way or are unnecessary. There are also some settings that are
	not set by default to avoid confusing new users. And like the set defaults,
	some of them may be very useful once you are more familiar with Emacs.

  | Keybind   | Command                   | Description                                     |
  |-----------+---------------------------+-------------------------------------------------|
  | SPC w d   | delete-window             | Delete (close) the currently focused window.    |
  | SPC w s h | split-window-vertically   | Split the window, resulting in two vertically  |
  |           |                           | side-by-side windows.                           |
  | SPC w s v | split-window-horizontally | Split the window, resulting in two horizontally |
  |           |                           | side-by-side windows.                           |

   #+BEGIN_SRC emacs-lisp
     (use-package emacs
       :ensure nil
       :config
       ;; Force syntax highlighting for all supported major modes.
       (global-font-lock-mode t)

       ;; Change the "Yes or No" prompt to just be "y or n".
       (defalias 'yes-or-no-p 'y-or-n-p)

       ;;; Keybinds
       (general-define-key
        :states 'normal
        :prefix "SPC w"
        "d" 'delete-window
        "s h" 'split-window-vertically
        "s v" 'split-window-horizontally)

       (general-define-key
        :states 'normal
        :prefix "SPC e"
        "N" 'widen)

       :custom
       ;;  Disable the startup screen & message.
       (inhibit-startup-screen t)

       ;; Disable the bell that makes me feel shame every time it lets me know I fumbled a
       ;; keystroke. Worse, its almost like hearing the bell guarantees the next
       ;; few strokes will also be fumbled resulting in more bells. Disable this
       ;; existential horror please.
       (ring-bell-function 'ignore); *ding-ding* SHAME. *ding-ding* SHAME.

       ;;	Show keystrokes after 0.1 seconds. Any longer and the panic sets in.
       (echo-keystrokes 0.01)

       ;; Do not show a dialog box when mouse commands result in a question
       ;; being asked. I actively avoid using the mouse, and accidently
       ;; triggering a popup is very frustrating.
       (use-dialog-box t)

       ;; Use spaces instead of tabs. And when tabs are seen, limit them to two
       ;; characters.
       (indent-tabs-mode nil)
       (tab-width 2)

       ;; Use UTF-8 encoding, because this is ${CURRENT_YEAR}.
       (locale-coding-system 'utf-8))
	 #+END_SRC

	 #+BEGIN_SRC emacs-lisp
     (use-package simple
       :ensure nil
       :config
       ;; Show column numbers on the modeline.
       (column-number-mode)

       ;; Show the size of the current buffer in the modeline.
       (size-indication-mode)

       ;; Visually wrap lines when the characters are too close to the fringe.
     (global-visual-line-mode 1)
       :custom
       ;; If the cursor is on the end of a line, stay on the end of the line when
       ;; moving to the next or previous line.
       (track-eol t)

       ;; Always show the current line number and column number
       ;; in the buffer. When both enabled, they appear like this:
       ;; ~~~
       ;; (line, col)
       ;; ~~~
       (line-number-mode t)
       (column-number-mode t)

       ;; Adds some curly arrows to help show which lines are being effected by
       ;; visual line wrapping.
       (visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow)))
	 #+END_SRC

	 Similarly, I like having which-key around to pat me on the back and tell
	 me I'm doing okay when I start a motion and forget where to go next.

	 #+BEGIN_SRC emacs-lisp
		 (use-package which-key
			 :hook (after-init . which-key-mode))
	 #+END_SRC

	 Automatically decompress archives when reading, and then compress again when
	 writing.

	 #+BEGIN_SRC emacs-lisp
		 (auto-compression-mode t)
	 #+END_SRC

   Enable the Garbage Collector Magic Hack. This will kick in the built in GC
   whenever the system is idle,

	 #+BEGIN_SRC emacs-lisp
     (use-package gcmh
       :ensure t
       :init
       (gcmh-mode 1))
	 #+END_SRC

   Describing things is one of the best ways to understand how Emacs works.
   Whenever I need to trouble shoot, the first thing I do is describe whatever
   it is I'm having problems with.

   | Keybind   | Command           | Description                                |
   |-----------+-------------------+--------------------------------------------|
   | SPC h d f | describe-function | Look up the definition of a function.      |
   | SPC h d k | describe-key      | Look up the function invoked by the        |
   |           |                   |  given key.                               |
   | SPC h d m | describe-mode     | Displays the documentation for the current |
   |           |                   | major and minor modes.                     |
   | SPC h d s | describe-symbol   | Look up the definition of a symbol.        |
   | SPC h d v | describe-variable | Look up the definition and value of a      |
   |           |                   | variable.                                  |

   #+BEGIN_SRC emacs-lisp
     (use-package help-fns
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :prefix "SPC h d"
        "f" 'describe-function
        "k" 'describe-key
        "m" 'describe-mode
        "s" 'describe-symbol
        "v" 'describe-variable))
	 #+END_SRC

** Files
   Of course, the core purpose of a file editor is to edit files. And when we
   have edited a file, that file needs to be saved. Emacs has plenty of built in
   saving functionality, as well as the ability to make plenty of backups in
   case you forgot to save.

		| Keybind | Command                    | Description                                   |
		|---------+----------------------------+-----------------------------------------------|
		| SPC q q | save-buffers-kill-terminal | Prompt to save all buffers, then close Emacs. |
		| SPC f r | save-buffer                | Save the currently focused buffer.            |
		| SPC f w | find-file                  | Navigate to a file via a tab-complete         |
		|         |                            | path editor.                                  |

   #+BEGIN_SRC emacs-lisp
     (use-package files
       :ensure nil
       :hook
       ;; Always delete trailing whitespace when saving a file.
       (before-save . delete-trailing-whitespace)

       ;; Automatically save buffers when losing focus, or when a frame is deleted.
       (focus-out-hook . save-some-buffers)
       (delete-frame-functions . save-some-buffers)

       :config
       ;;; Keybinds
       ;; Quit Emacs.
       (general-define-key
        :states 'normal
        :prefix "SPC q"
        "q" 'save-buffers-kill-terminal)

       ;; Read/write file.
       (general-define-key
        :states 'normal
        :prefix "SPC f"
        "w" 'save-buffer
        "r" 'find-file)

       :custom
       ;; Emacs auto-backups files, which is great. But, it dumps them in the current
       ;; directory, which is terrible. Instead, dump them into ~.emacs.d/~.
       (backup-directory-alist '(("." . "~/.emacs.d/backups")))

       ;; I don't want to have my hard drive littered with backups, so I set Emacs to
       ;; only keep up to three backup versions. I also don't want to have a nag every
       ;; time it wants to delete a backup. I also include version controlled files,
       ;; just in case.
       (version-control t)
       (kept-old-versions 2)
       (delete-old-versions t)
       (vc-make-backup-files t)

       ;; Always include a trailing newline at the end of a file.
       (require-final-newline t))
   #+END_SRC

   It is also very useful to automatically refresh buffers. That is: If the
   content of a buffer changes (such as a file changing on disk), then redraw
   the buffer. I also set it to refresh non-file buffers (such as Dired
   buffers), and to suppress the nag.

	 #+BEGIN_SRC emacs-lisp
     (use-package autorevert
       :ensure nil
       :config
       (global-auto-revert-mode t)
       :custom
       (global-auto-revert-non-file-buffers t)
       (auto-revert-verbose nil))
	 #+END_SRC

	 I also want to backup all of the commands I've used, so I can re-invoke them
   in later sessions. Command history is essential for any command based environment.

	 #+BEGIN_SRC emacs-lisp
     (use-package savehist
       :ensure nil
       :init
       (setq savehist-file "~/.emacs.d/savehist")
       (setq savehist-save-minibuffer-history +1)
       (setq savehist-additional-variables
             '(kill-ring
               search-ring
               regexp-search-ring))
       :config
       (savehist-mode))
	 #+END_SRC

   Tramp let's me use Emacs to edit remote files. For example, changing a Docker
   compose file from the comfort of my local machine. I default to editing over
   SSH instead of using SCP. [[https://www.emacswiki.org/emacs/TrampMode#toc12][I also need to override the shell prompt pattern to
   prevent Tramp from hanging.]]

	 #+BEGIN_SRC emacs-lisp
     (use-package tramp
       :ensure nil
       :custom
       (tramp-default-method "ssh" "SSH is faster than SCP.")
       (tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*"
                                   "Not having this pattern set causes Tramp to hang on connection."))
	 #+END_SRC

** Graphical User Interface
	 Seeing three bars on a slot machine is good. Seeing three bars on Emacs is bad.

	 #+BEGIN_SRC emacs-lisp
     (use-package menu-bar
       :ensure nil
       :config
       (menu-bar-mode -1))

     (use-package scroll-bar
       :ensure nil
       :config
       (scroll-bar-mode -1))

     (use-package tool-bar
       :ensure nil
       :config
       (tool-bar-mode -1))

     (use-package tooltip
       :ensure nil
       :defer t
       :custom
       (tooltip-mode -1))
	 #+END_SRC

	 Undo/Redo window layouts using C-c <left> and C-c <right>. Lets me fix
	 accidental destruction the layout of windows and buffers.

	 #+BEGIN_SRC emacs-lisp
     (use-package winner
       :ensure nil
       :config
       (winner-mode 1))
	 #+END_SRC

** Editor
*** Character Encoding & General Formatting
		Set the current font to [[https://typeof.net/Iosevka/][Iosevka Term SS04]] with a size of 11.

		#+BEGIN_SRC emacs-lisp
			(add-to-list 'default-frame-alist '(font . "Iosevka Term SS04-11"))
		#+END_SRC

		Use UTF-8 encoding everywhere. I rarely run Emacs in a terminal, and even then
		my terminal of choice also supports UTF-8. No reason to not enable.

		#+BEGIN_SRC emacs-lisp
      (use-package mule
        :ensure nil
        :config
        (set-terminal-coding-system 'utf-8)
        (set-keyboard-coding-system 'utf-8)
        (set-selection-coding-system 'utf-8)
        (prefer-coding-system 'utf-8))
		#+END_SRC

		To congratulate myself for taking a stand against non-UTF-8 encoding, I will
		reward myself with some pretty symbols.

		#+BEGIN_SRC emacs-lisp
			(use-package pretty-mode
				:config
				(global-pretty-mode t))
		#+END_SRC

		Always include a trailing newline at the end of a file. As well, disable
		sentences ending with a double space. I don't think I've ever seen someone
		do this in real life, and to be frank I don't think I want to meet the people
		that do.

		#+BEGIN_SRC emacs-lisp
			(setq sentence-end-double-space nil)
		#+END_SRC

*** Colour Theme
		I've recently switched over to the [[https://github.com/fniessen/emacs-leuven-theme][Leuven]] theme. I've started switching
		over to light-themes for my systems in general. I keep my brightness
		relatively low, so dark-themes end up having poor contrast. Leuven
		was built with Org-mode in mind, and gives Org files a more cohesive
		feeling.

		#+BEGIN_SRC emacs-lisp
      (use-package leuven-theme
        :ensure t
        :config
        ;; Load the theme unless running without an interactive terminal.
        (unless noninteractive
          (load-theme 'leuven t)))
		#+END_SRC

*** Highlighting & Pair Matching
    Highlight the row the cursor is currently on.

    #+BEGIN_SRC emacs-lisp
      (use-package hl-line
        :config
        (global-hl-line-mode))
    #+END_SRC

    When the cursor is over a parenthesis, highlight all of the content between
    that parenthesis and it's matching opening/closing parenthesis. This is
    mostly useful when working with Lisp, but I have found it helpful in other
    situations as well. So I set it globally.

    #+BEGIN_SRC emacs-lisp
      (use-package paren
        :config
        (show-paren-mode)
        :custom
        (show-paren-style 'expression)
        (show-paren-delay 0))
    #+END_SRC

    Automatically insert a closing symbol if an opening symbol is entered
    (paren., bracket, brace, etc.). The closing symbol is after the point
    of the cursor, so I can keep typing without having to adjust to the
    newly entered text.

    #+BEGIN_SRC emacs-lisp
      (use-package elec-pair
        :config
        (electric-pair-mode))
    #+END_SRC

*** Doom Modeline
		A """minimalist""" modeline. It's minimalist, so that justifies satisfying
		my need for fancy colours and icons everywhere I look so I can keep my ADD
		rattled brain distracted while the rest of me tries to do real work.

		#+BEGIN_SRC emacs-lisp
			(use-package doom-modeline
				:hook (after-init . doom-modeline-mode))

			(use-package all-the-icons)
		#+END_SRC

*** Relative Line Numbering
		I really like Vim's relative line number feature. I find it makes taking
		advantage of motions easier since it removes any sort of mental math. I
		use the [[https://github.com/coldnew/linum-relative][linum-relative]] package for this.

		#+BEGIN_SRC emacs-lisp
			(use-package linum-relative
				:init
				;; ~display-line-numbers-mode~ is the faster backend on Emacs 26
				(setq linum-relative-backend 'diplay-line-numbers-mode)
				:config
				(linum-relative-global-mode 1))
		#+END_SRC

*** Smooth Scrolling
		Leaves just a bit of room at the bottom and top of the window when
		scrolling. Something about it just feels so right. Uses the
		[[https://github.com/aspiers/smooth-scrolling][smooth-scrolling package]] .

		#+BEGIN_SRC emacs-lisp
			(use-package smooth-scrolling
				:config
				(smooth-scrolling-mode 1))
		#+END_SRC

* Evil Mode
	Vim has the superior input style. There. I said it. Modal-based bindings flow so much
  better for me, both in thinking and in executing. Using Emacs native modifier bindings
  feels incredibly restrictive in comparison. My left hand needs to positioned to always
  be able to hold down Control, Alt, or Meta. Making my pinky the main work-horse of
  my typing, to me, feels like a terrible mistake. On the other hand, modal style editing
	lets me use my fingers equally. Even when I need to use some sort of modifier key (mostly
  the space bar), it ends up being my thumb doing the work. My thumb can withstand the
  brute force of slamming it down in frustration during a heated moment. My pinky is
  barely even an appendage.

	Evil mode gives me Vim-like keybindings without having to invest in any sort of
  remapping. I, of course, still add my own mappings and re-mappings. Not because Vim
  lacks anything, but entirely due to personal preference. Without Evil, I don't think
  I could see myself ever using Emacs seriously.

  | Keybind   | Command                   | Description                                     |
  |-----------+---------------------------+-------------------------------------------------|
  | SPC w h   | evil-window-left          | Focus the window to the left.                   |
  | SPC w j   | evil-window-bottom        | Focus the window below.                         |
  | SPC w k   | evil-window-up            | Focus the window above.                         |
  | SPC w l   | evil-window-right         | Focus the window to the right.                  |

  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :config
      (evil-mode))

    (use-package evil-core
      :ensure nil
      :config
      (evil-set-initial-state 'ibuffer-mode 'normal))

    (use-package evil-commands
      :ensure nil
      :config
      (general-define-key
       :states 'normal
       :prefix "SPC w"
       "h" 'evil-window-left
       "j" 'evil-window-down
       "k" 'evil-window-up
       "l" 'evil-window-right))

    (use-package evil-commentary
      :ensure t
      :config
      (progn
        ;; Enable by default
        (evil-commentary-mode)))
  #+END_SRC

* ido
 [[https://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] (Interactively Do Things) is a built-in minor mode that provides
 "interactive" text entry. This mostly means the minibuffer will filter away all
 entries that could not match your input without having to hit ~TAB~ each time.

  #+BEGIN_SRC emacs-lisp
    (use-package ido
      :ensure nil
      :config
      (ido-mode)
      :custom
      (ido-everywhere t "Enables ido for all buffer/file reading.")
      (ido-enable-flex-matching t "If no prefix matches are found, look for the \
                                    sequence of characters anywhere in an entry."))
  #+END_SRC

  I do not like the default in-line display used by ido. [[https://github.com/creichert/ido-vertical-mode.el][Ido-vertical-mode]] reads
  better to me, displaying all entries in a single column.

  I would prefer something grid-like, such as [[https://github.com/larkery/ido-grid-mode.el][ido-grid-mode]], but I have found it
  slows down Emacs too much.

  #+BEGIN_SRC emacs-lisp
    (use-package ido-vertical-mode
       :ensure t
       :after ido
       :config
       (ido-vertical-mode)
       :custom
       (ido-vertical-define-keys 'C-n-and-C-p-only "Use C-n/C-p to move selection."))

  #+END_SRC

  Ido-everywhere unfortunately does not apply everywhere. To get Ido completion
  nearly everywhere, I use the [[https://github.com/DarwinAwardWinner/ido-completing-read-plus][ido-completing-read+]] package. Assisting is the
  [[https://github.com/DarwinAwardWinner/crm-custom][crm-custom]] package that allows Ido completion in functions that can take in
  multiple inputs.

  To supplement anything else that doesn't get Ido completion, I enable the
  built-in ~icomplete~ mode.

  #+BEGIN_SRC emacs-lisp
    (use-package ido-completing-read+
      :ensure t
      :after ido
      :config
      (ido-ubiquitous-mode))

    (use-package crm-custom
      :ensure t
      :after ido-completing-read+
      :config
      (crm-custom-mode))

    (use-package icomplete
      :after ido-completing-read+
      :config
      (icomplete-mode))
  #+END_SRC

* iBuffer
	iBuffer is a great tool for managing the many buffers created in day-to-day
	Emacs use.

  | Keybind | Command | Description               |
  |---------+---------+---------------------------|
  | SPC b b | ibuffer | Open the iBuffer...buffer |

  #+BEGIN_SRC emacs-lisp
    (use-package ibuffer
      :ensure nil
      :config
      ;;; Keybinds

      (general-define-key
       :states 'normal
       :prefix "SPC b"
       "b" 'ibuffer)

      (general-define-key
       :states 'normal
       :keymaps 'ibuffer-mode-map
       "j" 'evil-next-line
       "k" 'evil-previous-line
       "l" 'ibuffer-visit-buffer
       "v" 'ibuffer-toggle-marks
       "m" 'ibuffer-mark-forward
       "u" 'ibuffer-unmark-forward
       "=" 'ibuffer-diff-with-file
       "J" 'ibuffer-jump-to-buffer
       "M-g" 'ibuffer-jump-to-buffer
       "M-s a C-s" 'ibuffer-do-isearch
       "M-s a M-C-s" 'ibuffer-do-isearch-regexp
       "M-s a C-o" 'ibuffer-do-occur
       "DEL" 'ibuffer-unmark-backward
       "M-DEL" 'ibuffer-unmark-all
       "* *" 'ibuffer-unmark-all
       "* M" 'ibuffer-mark-by-mode
       "* m" 'ibuffer-mark-modified-buffers
       "* u" 'ibuffer-mark-unsaved-buffers
       "* s" 'ibuffer-mark-special-buffers
       "* r" 'ibuffer-mark-read-only-buffers
       "* /" 'ibuffer-mark-dired-buffers
       "* e" 'ibuffer-mark-dissociated-buffers
       "* h" 'ibuffer-mark-help-buffers
       "* z" 'ibuffer-mark-compressed-file-buffers
       "." 'ibuffer-mark-old-buffers

       "d" 'ibuffer-mark-for-delete
       "C-d" 'ibuffer-mark-for-delete-backwards
       "x" 'ibuffer-do-kill-on-deletion-marks

       ;; immediate operations
       "n" 'ibuffer-forward-line
       "SPC" 'forward-line
       "p" 'ibuffer-backward-line
       "M-}" 'ibuffer-forward-next-marked
       "M-{" 'ibuffer-backwards-next-marked
       "g" 'ibuffer-update
       "," 'ibuffer-toggle-sorting-mode
       "s i" 'ibuffer-invert-sorting
       "s a" 'ibuffer-do-sort-by-alphabetic
       "s v" 'ibuffer-do-sort-by-recency
       "s s" 'ibuffer-do-sort-by-size
       "s f" 'ibuffer-do-sort-by-filename/process
       "s m" 'ibuffer-do-sort-by-major-mode

       "/ m" 'ibuffer-filter-by-used-mode
       "/ M" 'ibuffer-filter-by-derived-mode
       "/ n" 'ibuffer-filter-by-name
       "/ c" 'ibuffer-filter-by-content
       "/ e" 'ibuffer-filter-by-predicate
       "/ f" 'ibuffer-filter-by-filename
       "/ >" 'ibuffer-filter-by-size-gt
       "/ <" 'ibuffer-filter-by-size-lt
       "/ r" 'ibuffer-switch-to-saved-filters
       "/ a" 'ibuffer-add-saved-filters
       "/ x" 'ibuffer-delete-saved-filters
       "/ d" 'ibuffer-decompose-filter
       "/ s" 'ibuffer-save-filters
       "/ p" 'ibuffer-pop-filter
       "/ !" 'ibuffer-negate-filter
       "/ t" 'ibuffer-exchange-filters
       "/ TAB" 'ibuffer-exchange-filters
       "/ o" 'ibuffer-or-filter
       "/ g" 'ibuffer-filters-to-filter-group
       "/ P" 'ibuffer-pop-filter-group
       "/ D" 'ibuffer-decompose-filter-group
       "/ /" 'ibuffer-filter-disable

       "M-n" 'ibuffer-forward-filter-group
       "\t" 'ibuffer-forward-filter-group
       "M-p" 'ibuffer-backward-filter-group
       [backtab] 'ibuffer-backward-filter-group
       "M-j" 'ibuffer-jump-to-filter-group
       "C-k" 'ibuffer-kill-line
       "C-y" 'ibuffer-yank
       "/ S" 'ibuffer-save-filter-groups
       "/ R" 'ibuffer-switch-to-saved-filter-groups
       "/ X" 'ibuffer-delete-saved-filter-groups
       "/ \\" 'ibuffer-clear-filter-groups

       "% n" 'ibuffer-mark-by-name-regexp
       "% m" 'ibuffer-mark-by-mode-regexp
       "% f" 'ibuffer-mark-by-file-name-regexp

       "C-t" 'ibuffer-visit-tags-table

       "|" 'ibuffer-do-shell-command-pipe
       "!" 'ibuffer-do-shell-command-file
       "~" 'ibuffer-do-toggle-modified
       "A" 'ibuffer-do-view
       "D" 'ibuffer-do-delete
       "E" 'ibuffer-do-eval
       "F" 'ibuffer-do-shell-command-file
       "I" 'ibuffer-do-query-replace-regexp
       "H" 'ibuffer-do-view-other-frame
       "N" 'ibuffer-do-shell-command-pipe-replace
       "M" 'ibuffer-do-toggle-modified
       "O" 'ibuffer-do-occur
       "P" 'ibuffer-do-print
       "Q" 'ibuffer-do-query-replace
       "R" 'ibuffer-do-rename-uniquely
       "S" 'ibuffer-do-save
       "T" 'ibuffer-do-toggle-read-only
       "U" 'ibuffer-do-replace-regexp
       "V" 'ibuffer-do-revert
       "W" 'ibuffer-do-view-and-eval
       "X" 'ibuffer-do-shell-command-pipe

       "w" 'ibuffer-copy-filename-as-kill

       "e" 'ibuffer-visit-buffer
       "f" 'ibuffer-visit-buffer
       "C-x C-f" 'ibuffer-find-file
       "o" 'ibuffer-visit-buffer-other-window
       "C-o" 'ibuffer-visit-buffer-other-window-noselect
       "M-o" 'ibuffer-visit-buffer-1-window
       "C-x v" 'ibuffer-do-view-horizontally
       "C-c C-a" 'ibuffer-auto-mode
       "C-x 4 RET" 'ibuffer-visit-buffer-other-window
       "C-x 5 RET" 'ibuffer-visit-buffer-other-frame))
	#+END_SRC

* Dired-X
  Dired-X is the extended version of the Emacs file manager Dired. I'll be
  honest, I do not use Dired-X very often. If I need to read a file, I'd
  rather use the ~fine-file~ command and navigate my file system using
  a path. For all file system level operations, I would much rather
  switch to my shell. My Dired-X usage is mostly if I need to open a file
  and I've forgotten the name and need a list of files/directories. And
  even then, it's only if I feel pressed for time, or if a coworker is
  over my shoulder.

  The keybinds are only for vim-like navigation. Nothing special exists
  outside of those.

  I customise how the file system is displayed. Dired takes in standard ~ls~
  flags, which is really nice.

  | Switch                    | Description                                         |
  |---------------------------+-----------------------------------------------------|
  | -k                        | Default to 1024-byte blocks for disk usage.         |
  | -a                        | Do not ignore entries starting with ~.~.            |
  | -B                        | Do not list implied entries ending with =~=.        |
  | -h                        | Use human readable file sizes (1G instead of 1024). |
  | -l                        | Use a long listing format.                          |
  | --group-directories-first | Show directories at the top of the listing.         |

  | Keybind | Command    | Description                                     |
  |---------+------------+-------------------------------------------------|
  | SPC b d | dired      | Prompt for a path, and open Dired at that path. |
  | SPC b D | dired-jump | Opens Dired in the directory of the currently   |
  |         |            | focused buffer.                                 |

  #+BEGIN_SRC emacs-lisp
    (use-package dired-x
      :ensure nil
      :config
      ;; Disable nag when jumping to another dired-x buffer
      (put 'dired-find-alternate-file 'disable nil)

      ;;; Keybinds
      ;; Get to the Dired buffer.
      (general-define-key
       :states 'normal
       :prefix "SPC b"
       "d" 'dired
       "D" 'dired-jump)

      ;; Remapping Dired commands
      (general-define-key
       :states 'normal
       :keymaps 'dired-mode-map
       "l" 'dired-find-alternate-file
       "h" 'my-dired-up-directory
       "o" 'dired-sort-toggle-or-edit
       "v" 'dired-toggle-marks
       "m" 'dired-mark
       "u" 'dired-unmark
       "U" 'dired-unmark-all-marks
       "c" 'dired-create-directory
       "n" 'evil-search-next
       "N" 'evil-search-previous
       "q" 'kill-this-buffer)
      :custom
      (dired-listing-switches "-kaBhl --group-directories-first"))
  #+END_SRC

* Magit
	Magit is a Git porcelain for Emacs. Just like with Dired-X, I normally
	default to the shell and use the Git CLI. However, I've heard such
	good things about Magit that I figure I should give it a proper shot.

  | Keybind | Command | Description                   |
  |---------+---------+-------------------------------|
  | SPC g s | magit   | Open the Magit status buffer. |

  #+BEGIN_SRC emacs-lisp
    (use-package magit
      ;; Don't load Magit on my work (Windows) machine.
      :if (eq system-type 'gnu/linux)
      :ensure t
      :config
      (general-define-key
       :states 'normal
       :prefix "SPC g"
       "s" 'magit)

      :custom
      (magit-completing-read-function 'magit-ido-completing-read "Use Ido completion."))
	#+END_SRC

  I am using the black magic [[https://github.com/emacs-evil/evil-magit][~evil-magit~]] package for Magit's keybinds. The
  defaults seem sane enough, so I am going to stick with them until I feel like
  it needs some configuration.

	#+BEGIN_SRC emacs-lisp
    (use-package evil-magit
      :ensure t
      :requires magit)
	#+END_SRC

* Spellchecking
  I use Emacs for writing documents on a regular basis. Usually this means
  an ~org~ or Markdown file, but this could also be LaTeX files. I also
  this also could be comments within source code. Lastly, I like to draft emails
  within Emacs. This means I need spellchecking on the fly within Emacs to keep
  my documents professional. Flyspell is /the/ package for spell checking in
  Emacs. I use the popup menu from ~flyspell-correct~ to go through correction
  options. I also use ~auto-dictionary~ to automatically switch between
  dictionaries. I need this occasionally to go between English and French
  documents.

    | Keybind | Command                   | Description                                             |
    |---------+---------------------------+---------------------------------------------------------|
    | SPC s b | flyspell-buffer           | Manually invoke flyspell and check the entire buffer.   |
    | SPC s c | flyspell-correct-at-point | Correct the spelling of the work underneath the cursor. |
    | SPC s n | flyspell-goto-next-error  | Move the cursor to the next Flyspell error.             |
    | SPC t s | flyspell-mode             | Toggle flyspell in the current buffer.                  |

  #+BEGIN_SRC emacs-lisp
    (use-package flyspell
      :hook
      ;; Auto-start flyspell within Markdown, Org-mode, and TeX files
      ((markdown-mode org-mode latex-mode git-commit-mode) . flyspell-mode)

      :config
      (general-define-key
       :states 'normal
       :prefix "SPC s"
       "b" 'flyspell-buffer
       "c" 'flyspell-correct-at-point
       "n" 'flyspell-goto-next-error)

      (general-define-key
       :states 'normal
       :prefix "SPC t"
       "s" 'flyspell-mode))

    (use-package flyspell-correct-popup)

    (use-package auto-dictionary
      :hook (flyspell-mode . auto-dictionary-mode))
  #+END_SRC

* Programming
	A little known fact. Occasionally, I use Emacs to program. Outrageous
	I know, but it's true. For any language I use, I try to leverage a
	Language Server if available. Using a lang server simplifies the setup,
	and allows me to share one server configuration across several editors.
	As long as the functionality is in the server, I can guarantee it will
	be available in every editor I use. If no lang. server is available, or
	if there is some functionality not available in the lang. server, I will
  fall back to some sort of ~lang-mode~ package. Using both is also a valid
	option, as long as they do not conflict or result in displaying some chunks
	of information twice.

  | Keybind | Command                 | Description                                       |
  |---------+-------------------------+---------------------------------------------------|
  | SPC e b | lsp-format-buffer       | Format the entire buffer.                         |
  | SPC e o | lsp-organize-imports    | If possible, organize all imports in the buffer.  |
  | SPC e r | lsp-rename              | Rename the item at point across the project.      |
  | SPC e a | lsp-execute-code-action | Execute a code action based on the current point. |

  #+BEGIN_SRC emacs-lisp
    (use-package lsp-mode
      :hook (prog-mode . lsp)
      :config
      (general-define-key
       :states 'normal
       :prefix "SPC e"
       "b" 'lsp-format-buffer
       "o" 'lsp-organize-imports
       "r" 'lsp-rename
       "a" 'lsp-execute-code-action))
	#+END_SRC

	Flycheck is used for some linting by ~lsp-mode~.

  | Keybind   | Command                      | Description                                       |
  |-----------+------------------------------+---------------------------------------------------|
  | SPC e n   | flycheck-next-error          | Go to the next error.                             |
  | SPC e p   | flycheck-previous-error      | Go to the previous error.                         |

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :config
      ;; Flycheck by default
      (global-flycheck-mode)
      :custom
      ;; Disable flycheck on checkdoc
      (flycheck-disabled-checkers '(emacs-lisp-checkdoc))

      ;;; Keybinds
      (general-define-key
       :states 'normal
       :prefix "SPC e"
       "n" 'flycheck-next-error
       "p" 'flycheck-previous-error))

	#+END_SRC

	Company is the completion framework I leverage with ~lsp-mode~.

	#+BEGIN_SRC emacs-lisp
    (use-package company
      :config
      (global-company-mode))

    (use-package company-lsp
      :config
      ;; Add company-lsp as a backend to company-mode
      (push 'company-lsp company-backends)
      :custom
      ;; Cache completions if the cached results are incomplete
      (company-lsp-cache-candidates 'auto)

      ;; Fetch completion results asynchronously. No need to lock up just to
      ;; fetch results from the language server.
      (company-lsp-async t)

      ;; Enable snippet expansion from the language sever.
      (company-lsp-enable-snippet t)

      ;; Allow recompletion in the case there are other completion trigger
      ;; characters.
      (company-lsp-enable-recompletion t))
	#+END_SRC

	~lsp-ui~ gives much higher-level interactions with ~lsp-mode~:

	- Doc :: Fetch documentation and display it in a popup buffer.
	- Flycheck :: LSP interactions via Flycheck, like outputting the full list
							 and navigating between info/warnings/errors.
	- iMenu :: LSP interaction via ~imenu~.
	- Peek :: Enable peeking & jumping to definitions.
	- Sideline :: Display LSP actions and Flycheck output on the right-hand side
							 of the buffer.

	I deliberately disable the Doc functionality, as I find it intrusive. It also
	sometimes renders with an incorrect size. Instead, I have a key binding to
	enable/disable the Doc. The same goes for the ~imenu~ buffer.

	I change the face for the peek references to match the Leuven ~org-block~
	colours.

	The Sideline is a feature that I used to also disable, but after tweaking it
	a bit and removing the symbol information I find it very handy. The few tweaks
	I make are changing the face to match the ~ol1~ face from Leuven theme, and
	adding a prefix to the code actions panel. The only issue I still have with it
	is the Flycheck diagnostic information for /info/ showing up as a hideously
	bright green.

  | Keybind   | Command                      | Description                                      |
  |-----------+------------------------------+--------------------------------------------------|
  | SPC e l   | lsp-ui-flycheck-list         | Open the flycheck buffer.                        |
  | SPC e f d | lsp-ui-peek-find-definitions | Peek find the definition of the item at point.   |
  | SPC e f r | lsp-ui-peek-find-references  | Peek find all references to the item at point.   |
  | SPC e u   | toggle-lsp-ui-doc            | Show the doc window if the window is not already |
  |           |                              | visible.                                         |
  | SPC b m   | toggle-lsp-ui-imenu          | Show the imenu buffer if not already visible.    |

  #+BEGIN_SRC emacs-lisp
    (use-package lsp-ui
      :after lsp
      :hook (lsp . lsp-ui-mode)
      :config
      (defun max/toggle-lsp-ui-doc ()
        "Toggle the UI Doc"
        (interactive)
        (if (lsp-ui-doc--visible-p)
            (lsp-ui-doc-hide)
          (lsp-ui-doc-show)))

      (defun max/toggle-lsp-ui-imenu ()
        "Toggle the ~lsp-ui~ ~imenu~ buffer."
        (interactive)
        (if (get-buffer "*lsp-ui-imenu*")
            (kill-buffer "*lsp-ui-imenu*")
          (lsp-ui-imenu)))

      ;;; Keybinds
      (general-define-key
       :states 'normal
       :prefix "SPC e"
       "f d" 'lsp-ui-peek-find-definitions
       "f r" 'lsp-ui-peek-find-references
       "l" 'lsp-ui-flycheck-list
       "u" 'max/toggle-lsp-ui-doc)

      (general-define-key
       :states 'normal
       :prefix "SPC b"
       "m" 'max/toggle-lsp-ui-imenu)

      ;; Fix 'q' not quiting the Flycheck list buffer
      ;; (general-define-key
      ;;  :states 'normal
      ;;  :keymap 'lsp-ui-flycheck-list-mode-map
      ;;  "q" 'lsp-ui-flycheck-list--quit)

      :custom
      (lsp-ui-sideline-enable t)
      (lsp-ui-sideline-ignore-duplicate t)
      (lsp-ui-sideline-code-actions-prefix " ℹ ")
      (lsp-ui-flycheck-enable t)
      (lsp-ui-doc-enable nil) ; Disable the Docs by default

      :custom-face
      (lsp-ui-sideline-code-action ((t (
                          :weight bold
                          :overline "#A7A7A7"
                          :foreground "#3C3C3C"
                          :background "#F0F0F0"))))

      (lsp-ui-peek-peek ((t (:background "#FFFFE0"))))
      (lsp-ui-peek-list ((t (:background "#FFFFE0"))))
      (lsp-ui-peek-filename ((t (
                            :foreground "#4183C4"
                            :background nil))))
      (lsp-ui-peek-highlight ((t (
                             :background "#F6FECD"
                             :slant italic))))
      (lsp-ui-peek-selection ((t (
                             :foreground "#333333"
                             :background "#F6FECD"))))
      (lsp-ui-peek-header ((t (
                          :underline "#A7A6AA"
                          :foreground "#555555"
                          :background "#E2E1D5"))))
      (lsp-ui-peek-footer ((t (
                          :underline "#A7A6AA"
                          :foreground "#555555"
                          :background "#E2E1D5")))))
	#+END_SRC

** Programming & Markup Languages
   The following are specific configurations for individual programming
   and markup languages.

*** Docker
    ~~~
    npm install --global dockerfile-language-server-nodejs
    ~~~

    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :mode (("Dockerfile\\'" . dockerfile-mode)))
    #+END_SRC

*** Emacs Lisp
    #+BEGIN_SRC emacs-lisp
      (use-package elisp-slime-nav
        :hook (emacs-lisp-mode . elisp-slime-nav-mode)
        :config
        (general-define-key
         :states 'normal
         :prefix "SPC m"
         "e" 'pp-eval-last-sexp))

    #+END_SRC

*** Golang
    ~~~
    go get gopls
    ~~~

    #+BEGIN_SRC emacs-lisp
      (use-package go-mode
        :hook (before-save . gofmt-before-save)
        :custom
        ;; Run goimports before saving a file
        (gofmt-command "goimports"))
    #+END_SRC

*** Markdown
    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :commands (markdown-mode gfm-mode)
        ;; Use GitHub markdown on README.md files, and regular Markdown on others
        :mode (("README\\.md'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)))
    #+END_SRC

*** Typescript
    #+BEGIN_SRC emacs-lisp
      (use-package typescript-mode)
      (use-package json-mode)
    #+END_SRC

* Org-mode
	Org-mode was the killer feature that got me to try out Emacs to begin with,
	and honestly it's probably the main reason I keep using Emacs.

	I have tried many solutions to low tech or plain text note taking and
	productivity tools, but until org-mode I was constantly disappointed.
	Todo.txt, Markdown, XML with custom schemas, and Bullet Journals.
	Bullet Journals was the closest to a perfect solution, but my natural
  tendency to forget my journal at home lead to me dropping it as well.

	Combining org-mode with Orgzly and Syncthing has become my perfect
	organization, productivity, and note taking stack.

	The location of my Org files differs depending on what machine I am on. On my
	personal machine, the directory is ~/home/max/doc/org/~. It is synced to
  Nextcloud as a backup solution, and synced to my mobile phone with Syncthing.
  On my work machine, it is under ~F:\org\~. This drive is a network drive. Not
	really a backup, but better than only keeping it local.

  I keep three sequences for todo keywords. The task sequence, the blocked
  sequence, and the financial sequence. The task sequence is for tasks
  that are ongoing and not impeded. The blocked sequence are for tasks that I
  cannot actively work on. The financial sequence is for not forgetting to
  pay my phone bill again.

  The ~RAW~ state is for tasks that have been captured, but haven't yet been
  fleshed out. Maybe the task is just an idea, or it needs more information
  before it's actionable.

  The ~WAITING~, ~HOLD~, ~CANCELLED~, and ~OVERDUE~ state leave a timestamp
  and a require a comment whenever it is switched too. I use to document why
  a task has reached this (usually negative) state.

  I use tags to help prioritise my work. I use the Eisenhower matrix to
  prioritise my work. Each task is prioritised as either important or not
  important, and urgent or not urgent. Priority is assigned then from where
  on the matrix the task falls:

  1. Important & Urgent (Do ASAP)
  2. Important & Not Urgent (Schedule)
  3. Not Important & Urgent (Delegate if possible)
  4. Not Important & Not Urgent (Do it later)

  I use the ~PROJECT~ tag to indicate that all sub-headers are part of the same
  overarching task defined in the tagged header. I make sure to exclude this
  tag from the inheritance list so all sub-headers do not get the ~PROJECT~
  tag.

   | Keybind   | Command                         | Description                                          |
   |-----------+---------------------------------+------------------------------------------------------|
   | SPC m S h | org-demote-subtree              | Demote the entire subtree down one level.            |
   | SPC m S j | org-move-subtree-down           | Move the subtree below the subtree                   |
   |           |                                 | immediately after it.                                |
   | SPC m S k | org-move-subtree-up             | Move the subtree above the subtree                   |
   |           |                                 | immediately before it.                               |
   | SPC m S l | org-promote-subtree             | Promote the entire subtree up one level.             |
   | TAB       | org-cycle                       | Cycle the state of the headline at point (open/close |
   |           |                                 | headlines).                                          |
   | $         | org-end-of-line                 | Move cursor to the end of the line.                  |
   | ^         | org-beginning-of-line           | The opposite of ~$~                                  |
   | gh        | outline-up-heading              | Move cursor up one heading level.                    |
   | gj        | org-forward-heading-same-level  | Move cursor down one heading within the same level.  |
   | gk        | org-backward-heading-same-level | Move cursor up one heading within the same level.    |
   | gl        | outline-next-visible-heading    | Move cursor down one heading level.                  |
   | t         | org-todo                        | Change keyword state of heading.                     |
   | T         | org-insert-todo-heading         | Insert a heading at point with TODO keyword already  |
   |           |                                 | in place.                                            |
   | SPC m x b | max/org-bold-region             | Surround entire region with ~*~.                     |
   | SPC m x c | max/org-code-region             | Surround entire region with ~\~~.                    |
   | SPC m x i | max/org-italic-region           | Surround entire region with ~/~.                     |
   | SPC m x s | max/org-strike-through-region   | Surround entire region with ~+~.                     |
   | SPC m x u | max/org-underline-region        | Surround entire region with ~_~.                     |
   | SPC m x v | max/org-verbatim-region         | Surround entire region with ~=~.                     |
	 | SPC m h i | org-insert-heading-after-current | Exactly what it sounds like.                      |
	 | SPC m h I | org-insert-heading               | Insert heading at current point.                  |
	 | SPC m h s | org-insert-subheading            | Creates a new heading one level below the current |
	 |           |                                  | heading.                                          |
	 | SPC m h l | org-insert-link                  | Insert a org-mode link at point.                 |
		| SPC m b   | org-tree-to-indirect-buffer        | Opens the current subtree into a buffer where   |
		|           |                                    | it is the sole subtree. This lets me edit the   |
		|           |                                    | tree without visible distractions of the        |
		|           |                                    | surrounding trees. As well, it removes the      |
		|           |                                    | chance of accidental manipulating an unrelated  |
		|           |                                    | tree.                                           |
		| SPC m d   | org-deadline                       | Adds a deadline to the entry.                   |
		| SPC m D   | org-insert-drawer                  | Inserts a drawer at the cursor with a prompted  |
		|           |                                    | name. Drawers are good for hiding information.  |
		| SPC m E   | org-set-effort                     | Creates an /effort/ property in the properties  |
		|           |                                    | drawer. I set effort in the estimated amount    |
		|           |                                    | of time it will take to do a task.              |
		| SPC m n   | org-narrow-to-subtree              | Like ~SPC m b~, but doesn't open a new buffer   |
		|           |                                    | that isolates the subtree.                      |
		| SPC m N   | widen                              | Undo ~SPC m n~.                                 |
		| SPC m o   | org-open-at-point                  | Opens whatever the pointer is on. Used mainly   |
		|           |                                    | for opening links.                              |
		| SPC m p   | org-set-property                   | Create a property with a given name and value.  |
		| SPC m r   | org-refile                         | Refile an entry.                                |
		| SPC m s   | org-scheduled                      | Sets the scheduled property of an entry.        |
		| SPC m t   | org-show-todo-tree                 | Show a tree of all todo's in the open buffer.   |
		| SPC m y   | org-todo-yesterday                 | Change the status of a headline, but apply it   |
		|           |                                    | as if it happened yesterday. Good if I forgot   |
		|           |                                    | to complete a habit style task.                 |
		| SPC m !   | org-time-stamp-inactive            | Creates an inactive timestamp.                  |
		| SPC m ^   | org-sort                           | Sorts the entire active tree.                   |
		| SPC m *   | org-toggle-heading                 | Toggled the data under the pointer into an org  |
		|           |                                    | heading.                                        |
		| SPC m RET | org-insert-heading-respect-content | Inserts a heading after the current subtree.    |
		| SPC m :   | org-set-tags                       | Set the tags on a heading at the current point. |
		| SPC m '   | org-edit-special                   | Used mostly when editing source code blocks     |
		|           |                                    | inside an org file.                             |
		| SPC m /   | org-sparse-tree                    | Create a sparse tree based on some filter       |
		|           |                                    | criteria.                                       |
		| SPC m .   | org-time-stamp                     | Create a time stamp.                            |

  #+BEGIN_SRC emacs-lisp
    (use-package org
      :ensure t
      :init
      ;;; Set the base directory depending on what OS I am currently on.
      (defvar org-base-dir)
      (if (eq system-type 'gnu/linux)
          ;; Linux
          (setq org-base-dir "/home/max/doc/org")
        ;; Windows
        (setq org-base-dir "f:/org"))

      ;; Linum mode on large (>1000 lines) Org files results in masive
      ;; slowdowns when going over a lot of collapsed lines.
      (add-hook 'org-mode-hook (lambda() (linum-relative-mode -1)))

      ;; Automatically wrap lines at the 80th column.
      (add-hook 'org-mode-hook (lambda() (set-fill-column 80) (auto-fill-mode)))

      :commands (org-mode org-capture org-agenda orgtbl-mode)
      :mode ("\\.org$" . org-mode)
      :config
      ;; The following variables are set here instead of in the ~:custom~ body
      ;; because the ~:custom~ body does not see variables set in the scope of
      ;; the ~:init~ body.
      (setq org-directory org-base-dir)
      (setq org-agenda-files (list (concat org-directory "/agenda")))
      (setq org-default-notes-file (concat (car org-agenda-files) "/inbox.org"))
      (setq org-archive-location (concat (car org-agenda-files) "/archive.org::* Archives"))

      ;; Functions to quickly emphasize a region.
      (defun max/org-bold-region ()
        (interactive)
        (org-emphasize ?\*))
      (defun max/org-code-region ()
        (interactive)
        (org-emphasize ?\~))
      (defun max/org-italic-region ()
        (interactive)
        (org-emphasize ?\/))
      (defun max/org-strike-through-region ()
        (interactive)
        (org-emphasize ?\+))
      (defun max/org-underline-region ()
        (interactive)
        (org-emphasize ?\_))
      (defun max/org-verbatim-region ()
        (interactive)
        (org-emphasize ?\=))

      ;;; Keybinds
      (general-define-key
       :states 'normal
       :keymaps 'org-mode-map
       :prefix "SPC m"
       "b" 'org-tree-to-indirect-buffer
       "d" 'org-deadline
       "D" 'org-insert-drawer
       "E" 'org-set-effort
       "n" 'org-narrow-to-subtree
       "o" 'org-open-at-point
       "p" 'org-set-property
       "r" 'org-refile
       "s" 'org-schedule
       "t" 'org-show-todo-tree
       "y" 'org-todo-yesterday
       "!" 'org-time-stamp-inactive
       "^" 'org-sort
       "*" 'org-toggle-heading
       "RET" 'org-insert-heading-respect-content
       ":" 'org-set-tags
       "'" 'org-edit-special
       "/" 'org-sparse-tree
       "." 'org-time-stamp)

      (general-define-key
       :states 'normal
       :keymaps 'org-mode-map
       :prefix "SPC m S"
       "h" 'org-demote-subtree
       "j" 'org-move-subtree-down
       "k" 'org-move-subtree-up
       "l" 'org-promote-subtree)

      (general-define-key
       :states 'normal
       :keymaps 'org-mode-map
       "TAB" 'org-cycle
       "$" 'org-end-of-line
       "^" 'org-beginning-of-line
       "gh" 'outline-up-heading
       "gj" 'org-forward-heading-same-level
       "gk" 'org-backward-heading-same-level
       "gl" 'outline-next-visible-heading
       "t" 'org-todo
       "T" 'org-insert-todo-heading)

      (general-define-key
       :states 'visual
       :keymaps 'org-mode-map
       :prefix "SPC m x"
       "b" 'max/org-bold-region
       "c" 'max/org-code-region
       "i" 'max/org-italic-region
       "s" 'max/org-strike-through-region
       "u" 'max/org-underline-region
       "v" 'max/org-verbatim-region)

      (general-define-key
       :states 'normal
       :keymaps 'org-mode-map
       :prefix "SPC m h"
       "i" 'org-insert-heading-after-current
       "I" 'org-insert-heading
       "s" 'org-insert-subheading
       "l" 'org-insert-link)

      :custom
      (org-log-done 'time "Inserts a timestamp on task completion.")
      (org-use-fast-todo-selection t "Enable jumping to specific states.")
      (org-todo-keywords
       '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)")
         (sequence "RAW(-)" "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")
         (sequence "EXPENSE(e)" "OVERDUE(o@/!)" "|" "PAID(p)")))
      (org-use-tag-inheritance t)
      (org-tags-exclude-from-inheritance '("PROJECT"))
      (org-tag-alist '(("important" . ?i)
                       ("urgent" . ?u)
                       ("!important" . ?I)
                       ("!urgent" . ?U)
                       ("PROJECT" . ?P)))
      (org-refile-use-outline-path t "
       Pick refile targets using paths. This works nicely with how I name bucket
       headlines for storing like tasks/notes.")
      (org-refile-targets '((org-agenda-files . (:maxlevel . 3))) "
    The refile targets are based off my agenda files, and only goes down three
    levels.")
      (org-fontify-done-headline t))
	#+END_SRC

	Org-bullets changes out the asterisks for UTF-8 symbols.

	#+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :hook (org-mode . org-bullets-mode))
  #+END_SRC

  Evil-org supplements missing keybinds until I get off my ass and define them.

   #+BEGIN_SRC emacs-lisp
	   (use-package evil-org
		   :after org
		   :config
		   (progn
			   (add-hook 'org-mode-hook 'evil-org-mode)
			   (add-hook 'evil-org-mode-hook
								   (lambda ()
									   (evil-org-set-key-theme)))
			   (require 'evil-org-agenda)
			   (evil-org-agenda-set-keys)))
   #+END_SRC

** Capture
	 Org-capture is a fantastic feature I wish I used more often. Most of the time
	 when capturing would be useful I'm away from my laptop. I use Orgzly's quick
	 note feature to accomplish a similar result, but the options for /how/ to
	 capture the information is far more limited than org-capture proper.

	 That being said, setting up capture templates for my work machine would
	 probably be a blessing. I'm on that thing 7.5 hours a day.

	 All templates are defined externally in ~*.txt~ files to keep this
	 configuration file clean. The goal of each template is to capture the minimum
   amount of information required for the item to be actionable (excluding the
   ~RAW~ capture). These are my templates:

   - Task :: An actionable todo item with a proper name, estimate, some sort of
            date, context tag, and priority tags. They are placed into the
            general task bucket in my main org file
   - Raw task :: An idea, task, or note that requires refinement. Could be a
                passing idea, a reminder, a quote, etc. Raw tasks are to never
                leave the my inbox.
   - Note :: A name, timestamp, content. Just a note.
   - Org Protocol Capture :: Used when capturing a web page via ~org-protocol~
        in Firefox. When used, it grabs the title of the web page, the full URL,
        and any text that was highlighted when the capture was initiated. This
        is the bookmarklet code:

   #+BEGIN_SRC javascript
   javascript:location.href='org-protocol://capture?template=p&url='+encodeURIComponent(location.href)
       + '&title='+encodeURIComponent(document.title)
       + '&body='+encodeURIComponent(window.getSelection())
   #+END_SRC

        | Keybind | Command              | Description                       |
        |---------+----------------------+-----------------------------------|
        | SPC m " | org-capture-finalize | Save and file the capture buffer  |
        | SPC m a | org-capture-kill     | Abandon the capture buffer        |

  #+BEGIN_SRC emacs-lisp
    (use-package org-capture
      :ensure nil
      :config
      ;;; Keybinds
      (general-define-key
       :states 'normal
       :prefix "SPC o"
       "c" 'org-capture)

      (general-define-key
       :states 'visual
       :keymaps 'org-capture-mode-map
       :prefix "SPC m"
       "'" 'org-capture-finalize
       "k" 'org-capture-kill)

      :custom
      (org-capture-templates
       '(("t" "Task" entry (file "~/doc/org/agenda/inbox.org")
          (file "~/.emacs.d/capture-templates/task.txt"))
         ("T" "Raw task" entry (file "~/doc/org/agenda/inbox.org")
          (file "~/.emacs.d/capture-templates/raw-task.txt"))
         ("n" "Note" entry (file "~/doc/org/agenda/inbox.org")
          (file "~/.emacs.d/capture-templates/note.txt"))
         ("j" "Journal Entry" entry (file+olp "~/doc/org/journal.org" "January" "W01")
          (file "~/.emacs.d/capture-templates/journal-entry.txt"))
         ("p" "Org Protocol Capture" entry (file "~/doc/org/agenda/inbox.org")
          (file "~/.emacs.d/capture-templates/protocol.txt")))))
	#+END_SRC

** Agenda
    | Keybind | Command         | Description                                     |
    |---------+-----------------+-------------------------------------------------|
    | SPC o a | org-agenda      | Opens the agenda command view. This lets me     |
    |         |                 | interactively decide how I want to use the      |
    |         |                 | org-mode agenda.                                |
    | SPC o o | org-agenda-list | Opens the agenda list view. Shows me my agenda  |
    |         |                 | For today and the next two days                 |
    | SPC o s | org-search-view | Opens the search view for org-mode. Lets me     |
    |         |                 | construct a complex search query.               |
    | SPC o t | org-tags-view   | Opens a view to filter org-mode items by tag.   |

	 #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :prefix "SPC o"
        "a" 'org-agenda
        "o" 'org-agenda-list
        "s" 'org-search-view
        "t" 'org-tags-view)

       :custom
       (org-agenda-span 3 "
         By default, show today and the next two days when opening the agenda.
         When planning ahead, three days is usually good enough to see if I'm
         overworking myself.")
       (org-agenda-tags-column -100 "
         Pushes off the tags if I'm viewing the agenda in a vertical split on the
         laptop. I'd rather see the content of the heading rather than the tags
         associated in most contexts."))
	 #+END_SRC

** Clock
		| Keybind   | Command                            | Description                                     |
		|-----------+------------------------------------+-------------------------------------------------|
		| SPC m i   | org-clock-in                       | Begin tracking the amount of time spent on a    |
		|           |                                    | task.                                           |
		| SPC m O   | org-clock-out                      | Stop tracking time against a specific task.     |
		| SPC m Q   | org-clock-cancel                   | Stop the current clock and undo all time        |
		|           |                                    | tracked.                                        |
	 #+BEGIN_SRC emacs-lisp
     (use-package org-clock
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :prefix "SPC m"
        "i" 'org-clock-in
        "O" 'org-clock-out
        "Q" 'org-clock-cancel))
	 #+END_SRC

** Archive
		| Keybind   | Command                            | Description                                     |
		|-----------+------------------------------------+-------------------------------------------------|
		| spc m a   | org-archive-subtree                | takes the current subtree and moves it to an    |
		|           |                                    | archive files. I do this periodically to hide   |
		|           |                                    | done state entries without deleting them.       |

	 #+BEGIN_SRC emacs-lisp
     (use-package org-archive
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m"
        "a" 'org-archive-subtree))
	 #+END_SRC

** Lists
		| Keybind   | Command                            | Description                                     |
		| SPC m c   | org-toggle-checkbox                | Toggles a checkbox between checked and empty.   |

	 #+BEGIN_SRC emacs-lisp
     (use-package org-list
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m"
        "c" 'org-toggle-checkbox))
	 #+END_SRC

** Export
		| Keybind   | Command                            | Description                                     |
		|-----------+------------------------------------+-------------------------------------------------|
		| SPC m e   | org-export-dispatch                | Opens the interactive export buffer. This is    |
		|           |                                    | used by me to export org files to PDF when      |
		|           |                                    | sharing my notes.                               |

	 #+BEGIN_SRC emacs-lisp
     (use-package ox
       :ensure nil
       :config
       (general-define-key
        :states 'normal
        :keymaps 'org-mode-map
        :prefix "SPC m"
        "e" 'org-export-dispatch))
	 #+END_SRC

** Source
   | Keybind | Command              | Description                       |
   |---------+----------------------+-----------------------------------|
   | SPC m ' | org-edit-src-exit    | Save and exit the org edit buffer |
   | SPC m k | org-edit-src-abort   | Abandon the changes in the buffer |

    #+BEGIN_SRC emacs-lisp
      (use-package org-src
        :ensure nil
        :config
        (general-define-key
         :states 'normal
         :keymaps ' org-src-mode-map
         :prefix "SPC m"
         "'" 'org-edit-src-exit
         "k" 'org-edit-src-abort))
		#+END_SRC

--
** Cliplink
   [[https://github.com/rexim/org-cliplink][org-cliplink]] grabs a URL from the clipboard, fetches the title of the web page,
   then inserts a link element with the URL as the link and the title as the
   description. I use this over ~org-protocol~ when I only want to use the web
   page as a reference point and not as an entry.

   | Keybind   | Command      | Description                       |
   |-----------+--------------+-----------------------------------|
   | SPC m L h | org-cliplink | Create a link based on the URL in |
   |           |              | the clipboard.                    |

   #+BEGIN_SRC emacs-lisp
    (use-package org-cliplink
      :ensure t
      :after org
      :config
      (general-define-key
       :states 'normal
       :keymaps 'org-mode-map
       :prefix "SPC m"
       "L" 'org-cliplink))
   #+END_SRC
